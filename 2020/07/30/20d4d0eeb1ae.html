<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>1 | Spinnaker: Agent 缓存云厂商各项数据流程分析 - 遇寻笔记</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="遇寻笔记"><meta name="msapplication-TileImage" content="/images/pics/d261cdb6203e0da42ae1324dd3aae11f.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="遇寻笔记"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="在 clouddriver 中缓存云厂商的各项数据，是由这些 agent 所来完成。本文主要聚焦于何时执行、如何存储、以及存储后如何使用这三点上。Agent 从哪里来创建 agent为每个云账号的每个区域创建10个不同类型的 agent安排启动ProviderUtils.rescheduleAgen"><meta property="og:type" content="article"><meta property="og:title" content="1 | Spinnaker: Agent 缓存云厂商各项数据流程分析"><meta property="og:url" content="https://eucham.me/2020/07/30/20d4d0eeb1ae.html"><meta property="og:site_name" content="遇寻笔记"><meta property="og:description" content="在 clouddriver 中缓存云厂商的各项数据，是由这些 agent 所来完成。本文主要聚焦于何时执行、如何存储、以及存储后如何使用这三点上。Agent 从哪里来创建 agent为每个云账号的每个区域创建10个不同类型的 agent安排启动ProviderUtils.rescheduleAgen"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://eucham.me/images/pics/a742e046f7b6b08ba478978897e970f1.png"><meta property="article:published_time" content="2020-07-30T12:36:46.000Z"><meta property="article:modified_time" content="2022-04-20T15:47:12.294Z"><meta property="article:author" content="遇寻"><meta property="article:tag" content="clouddriver"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://eucham.me/images/pics/a742e046f7b6b08ba478978897e970f1.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://eucham.me/2020/07/30/20d4d0eeb1ae.html"},"headline":"1 | Spinnaker: Agent 缓存云厂商各项数据流程分析","image":["https://eucham.me/images/pics/a742e046f7b6b08ba478978897e970f1.png"],"datePublished":"2020-07-30T12:36:46.000Z","dateModified":"2022-04-20T15:47:12.294Z","author":{"@type":"Person","name":"遇寻"},"publisher":{"@type":"Organization","name":"遇寻笔记","logo":{"@type":"ImageObject","url":"https://eucham.me/images/pics/d261cdb6203e0da42ae1324dd3aae11f.png"}},"description":"在 clouddriver 中缓存云厂商的各项数据，是由这些 agent 所来完成。本文主要聚焦于何时执行、如何存储、以及存储后如何使用这三点上。Agent 从哪里来创建 agent为每个云账号的每个区域创建10个不同类型的 agent安排启动ProviderUtils.rescheduleAgen"}</script><link rel="canonical" href="https://eucham.me/2020/07/30/20d4d0eeb1ae.html"><link rel="icon" href="/images/pics/d261cdb6203e0da42ae1324dd3aae11f.png"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.1/css/all.min.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?7d79380bb26079f6dd33da78e83cf2ab";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/pics/d261cdb6203e0da42ae1324dd3aae11f.png" alt="遇寻笔记" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/categories/AI">AI</a><a class="navbar-item" href="/categories/Kubernetes">Kubernetes</a><a class="navbar-item" href="/categories/Openstack">Openstack</a><a class="navbar-item" href="/categories/Docker">Container</a><a class="navbar-item" href="/categories/Golang">Golang</a><a class="navbar-item" href="/categories/Rust">Rust</a><a class="navbar-item" href="/about.html">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="To Find Me" href="https://github.com/eucham"><i class="fab fa-github"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="LinkedIn" href="https://www.linkedin.com/in/eucham"><i class="fab fa-linkedin"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-07-30T12:36:46.000Z" title="7/30/2020, 8:36:46 PM">2020-07-30</time>发表</span><span class="level-item"><time dateTime="2022-04-20T15:47:12.294Z" title="4/20/2022, 11:47:12 PM">2022-04-20</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Spinnaker/">Spinnaker</a></span><span class="level-item">19 分钟读完 (大约2819个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">1 | Spinnaker: Agent 缓存云厂商各项数据流程分析</h1><div class="content"><p>在 clouddriver 中缓存云厂商的各项数据，是由这些 agent 所来完成。本文主要聚焦于何时执行、如何存储、以及存储后如何使用这三点上。</p>
<h2 id="Agent-从哪里来"><a href="#Agent-从哪里来" class="headerlink" title="Agent 从哪里来"></a>Agent 从哪里来</h2><h3 id="创建-agent"><a href="#创建-agent" class="headerlink" title="创建 agent"></a>创建 agent</h3><p>为每个云账号的每个区域创建10个不同类型的 agent<br><img src="/images/pics/2c9cef4a329967384f9767218269fd17.png"></p>
<h3 id="安排启动"><a href="#安排启动" class="headerlink" title="安排启动"></a>安排启动</h3><p><code>ProviderUtils.rescheduleAgents()</code><br><img src="/images/pics/6a96b4a683502de73c079c6e4813cbc1.png"><br>上面的 agentScheduler 的实现类为 <code>com.netflix.spinnaker.cats.redis.cluster.ClusteredAgentScheduler</code>，具体操作就是将待添加的 100 个 agents 全部放到其中的 map 中，并以 accountName+region+className 作为 key。<br><img src="/images/pics/d0e3522ebebddbc50952256a9241ea4f.png"><br>到此时，已经把新增的 agents 全部安排好了。</p>
<h3 id="为什么加入到-agents-这个-map-中，agent-就能跑起来"><a href="#为什么加入到-agents-这个-map-中，agent-就能跑起来" class="headerlink" title="为什么加入到 agents 这个 map 中，agent 就能跑起来"></a>为什么加入到 agents 这个 map 中，agent 就能跑起来</h3><p>首先，ClusteredAgentScheduler 实现类 Runnable</p>
<p><img src="/images/pics/480a16cfc164a3efce99e2023c1a053c.png"></p>
<p>并且，在其实现的 run 方法中，会将所有的 agents 封装成一个 Runnable，然后丢到 agentExecutionPool 中执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    runAgents();</span><br><span class="line">  &#125;<span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">runAgents</span><span class="params">()</span> &#123;</span><br><span class="line">  Map&lt;String, NextAttempt&gt; thisRun = acquire();</span><br><span class="line">  activeAgents.putAll(thisRun);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> Map.Entry&lt;String, NextAttempt&gt; toRun : thisRun.entrySet()) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AgentExecutionAction</span> <span class="variable">exec</span> <span class="operator">=</span> agents.get(toRun.getKey());</span><br><span class="line">    agentExecutionPool.submit(<span class="keyword">new</span> <span class="title class_">AgentJob</span>(toRun.getValue(), exec, <span class="built_in">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ClusteredAgentScheduler-的-run-方法何时调用"><a href="#ClusteredAgentScheduler-的-run-方法何时调用" class="headerlink" title="ClusteredAgentScheduler 的 run 方法何时调用"></a>ClusteredAgentScheduler 的 run 方法何时调用</h3><p>首先 ClusteredAgentScheduler 作为一个 Runnable，被加入到一个 ScheduledExecutor 中，并且它的执行周期为 30s。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Executors.newSingleThreadScheduledExecutor(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NamedThreadFactory</span>(ClusteredAgentScheduler.class.getSimpleName())),</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">lockInterval</span> <span class="operator">=</span> agentLockAcquisitionIntervalSeconds == <span class="literal">null</span> ? <span class="number">1</span> : agentLockAcquisitionIntervalSeconds;</span><br><span class="line"></span><br><span class="line">lockPollingScheduler.scheduleAtFixedRate(<span class="built_in">this</span>, <span class="number">0</span>, lockInterval, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>agentLockAcquisitionIntervalSeconds 最终来源为 yaml 文件中的配置数值<br><img src="/images/pics/aa32298687653896c9f1ef26308c5eda.png"><br>即：<br><img src="/images/pics/72ed6d654e8674be96e058273763fcc6.png"></p>
<h3 id="如何执行到-agent-的拉取逻辑"><a href="#如何执行到-agent-的拉取逻辑" class="headerlink" title="如何执行到 agent 的拉取逻辑"></a>如何执行到 agent 的拉取逻辑</h3><p>上面的描述，并不是特别直观，执行到 agent 拉取逻辑的调用链路不是特别明显，它的调用链路如下：</p>
<ol>
<li>将 agent 以及 agent 中所产生的 AgentExecution 封装到 AgentExecutionAction 中，也就是前面所述的，将 agent 加入到某个 map 中，只是做了包装。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">agentScheduler.schedule(agent, agent.getAgentExecution(catsModule.providerRegistry), catsModule.executionInstrumentation)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 其中 agentExecution 最终来自 agent，也就是抽象类 CachingAgent 中的内部类。</span></span><br><span class="line"><span class="type">AgentExecutionAction</span> <span class="variable">agentExecutionAction</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">AgentExecutionAction</span>(agent, agentExecution, executionInstrumentation);</span><br></pre></td></tr></table></figure></li>
<li>将 AgentExecutionAction 包装到 AgentJob，即一个 Runnable 中，并提交到线程池中<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">AgentExecutionAction</span> <span class="variable">exec</span> <span class="operator">=</span> agents.get(toRun.getKey());</span><br><span class="line">agentExecutionPool.submit(<span class="keyword">new</span> <span class="title class_">AgentJob</span>(toRun.getValue(), exec, <span class="built_in">this</span>));</span><br></pre></td></tr></table></figure></li>
<li>在 <code>AgentJob</code> 的 run 方法中，执行 <code>AgentExecutionAction</code> 的 <code>execute()</code> 方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AgentExecutionAction action;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">Status</span> <span class="variable">status</span> <span class="operator">=</span> Status.FAILURE;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    status = action.execute();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    scheduler.agentCompleted(</span><br><span class="line">        action.getAgent().getAgentType(), lockReleaseTime.getNextTime(status));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在 <code>AgentExecutionAction</code> 中执行 agentExecution 的 executeAgent(agent) 方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executionInstrumentation.executionStarted(agent);</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    agentExecution.executeAgent(agent);</span><br><span class="line">    executionInstrumentation.executionCompleted(</span><br><span class="line">        agent, TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime));</span><br><span class="line">    <span class="keyword">return</span> Status.SUCCESS;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">    executionInstrumentation.executionFailed(agent, cause);</span><br><span class="line">    <span class="keyword">return</span> Status.FAILURE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>executeAgent 方法来到 CachingAgent 中，此时的调用栈就相对较清晰，如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeAgent</span><span class="params">(Agent agent)</span> &#123;</span><br><span class="line">  <span class="type">AgentIntrospection</span> <span class="variable">introspection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultAgentIntrospection</span>(agent);</span><br><span class="line">  <span class="type">CacheResult</span> <span class="variable">result</span> <span class="operator">=</span> executeAgentWithoutStore(agent); <span class="comment">// 此处进入 agent 拉取逻辑</span></span><br><span class="line">  introspection.finish(result);</span><br><span class="line">  CacheIntrospectionStore.getStore().recordAgent(introspection);</span><br><span class="line">  storeAgentResult(agent, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> CacheResult <span class="title function_">executeAgentWithoutStore</span><span class="params">(Agent agent)</span> &#123;</span><br><span class="line">  <span class="type">CachingAgent</span> <span class="variable">cachingAgent</span> <span class="operator">=</span> (CachingAgent) agent;</span><br><span class="line">  <span class="type">ProviderCache</span> <span class="variable">cache</span> <span class="operator">=</span> providerRegistry.getProviderCache(cachingAgent.getProviderName());</span><br><span class="line">  <span class="keyword">return</span> cachingAgent.loadData(cache); <span class="comment">// 调用 agent 的拉取逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><p>获取数据的入口是函数 <code>loadData()</code>，只负责从云账号拉取信息，并将信息按照一定的形式组装后返回，交给后续的逻辑处理模板进行处理。此处获取数据及组织数据的逻辑，根据 agent 类型的不同，有很大的出入，但是他们的共同点在于，组装所需返回的数据的形式。</p>
<p>以 <code>TencentImageCachingAgent</code> 为例，它有一个函数，实现了某个接口，如下：<br><img src="/images/pics/a022a731642bff63b4147e9913a11528.png"></p>
<p>这里有两个问题：</p>
<ol>
<li>函数 <code>getProvidedDataTypes()</code> 何时调用？用于什么场景？<br>在存储数据时进行调用，用来获取哪些数据项是可以覆盖更新的。</li>
<li>什么是 <code>AgentDataType</code>？有什么用处？<br>首先它有两个属性，分别为 <code>String typeName</code> 和 <code>Authority authority</code>，在此处 typeName 就是 NAMESPACE 中所对应的云主机所拥有的信息类型，而 authority 有两个值，一个是 AUTHORITATIVE 表示此数据是资源数据，一个是 INFORMATIVE 表示此数据为关联数据（起关联作用）。<br>typeName 的作用为对应后面存储操作时所需要操作的表等；authority 的作用则如上所述。</li>
</ol>
<p>最后，<code>loadData()</code> 函数返回的数据，就是以上述 <code>AgentDataType</code> 所包含的值作为 key 的 map。<br><img src="/images/pics/a150cb795d56552fe0174b8a059cdac4.png"></p>
<h2 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h2><p>在这一部分的代码中，逻辑非常多且略带抽象，因为这一部分代码，是所有 agent 拉完数据后，进行存储的统一模板代码，有部分代码处理个别 agent 数据的情况出现。但是化繁为简，它的目的就是做存储，并且此时的存储方式，有两种，资源对应 AUTHORITATIVE；关联数据对应 INFORMATIVE。抛开 agent 的差异，专注到存储的逻辑中，它的逻辑其实也很明了。<br>存储数据的位置在：CacheingAgent.java 的内部类 <code>CacheExecution</code> 的 <code>executeAgent()</code> 的最后一行，如下：<br><img src="/images/pics/d5b25f12828ebd5c75868fd13cc62f8f.png"></p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>从 <code>storeAgentResult(agent, result)</code> 出发。准备工作其实主要是确定 agent 拉回的数据，哪些是需要存储的，以及用什么样的方式进行存储。<br><img src="/images/pics/cddab04cae4e3cd99cc644bdbc2582c5.png"></p>
<p>进入 <code>SqlProviderCache.kt</code> 的 putCacheResult 方法。它的代码很长，但是主要根据 agent 数据类型的不同，最终调用两个方法，即：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> fun <span class="title function_">cacheDataType</span><span class="params">(type: String, agent: String, items: Collection&lt;CacheData&gt;, authoritative: Boolean, cleanup: Boolean)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> fun <span class="title function_">cacheDataType</span><span class="params">(type: String, agent: String, items: Collection&lt;CacheData&gt;, authoritative: Boolean)</span> &#123;</span><br><span class="line">    cacheDataType(type, agent, items, authoritative, cleanup = <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本质上是调用同一个方法，也就是第一个方法，只是入参会有所不同。所以 putCacheResult 的主要逻辑可归纳如下：</p>
<ol>
<li>根据 agent 返回数据不同，在 authoritativeTypes 中加入对应类型为资源的数据的 key。</li>
<li>如果 agent 返回数据的 key 中含有以 ON_DEMAND.ns，该 key 也加入到 authoritativeTypes 中，也属于资源数据。</li>
<li>此时分三种情况：<ol>
<li>如果 agentType 中含有 ON_DEMAND，那么拉取结果中的 ON_DEMAND.ns 对应的 key 将被视为属于资源数据。</li>
<li>如果 authoritativeTypes 不为空，那么拉取结果中，key 为 AUTHORITATIVE 类型的数据，将被视为属于资源数据。</li>
<li>非上述两种情况，对拉取结果中所有的数据，直接覆盖更新。</li>
</ol>
</li>
<li>对于非 AUTHORITATIVE 类型的数据，将视为属于关联数据。</li>
<li>有需要删除的项目，直接删除。</li>
</ol>
<p>上面便是对此函数的抽象概括，接下来进入实际的存储操作中。按照上面的分析，实际 db 操作包括两种，即增、删。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除相对比较简单。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">evictDeletedItems</span><span class="params">(type: <span class="type">String</span>, ids: <span class="type">Collection</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  backingStore.evictAll(type, ids)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">evictAll</span><span class="params">(type: <span class="type">String</span>, ids: <span class="type">Collection</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">var</span> deletedCount = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> opCount = <span class="number">0</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ids.chunked(dynamicConfigService.getConfig(<span class="built_in">Int</span>::<span class="keyword">class</span>.java, <span class="string">&quot;sql.cache.read-batch-size&quot;</span>, <span class="number">500</span>)) &#123; chunk -&gt;</span><br><span class="line">      withRetry(RetryCategory.WRITE) &#123;</span><br><span class="line">        jooq.deleteFrom(table(resourceTableName(type)))</span><br><span class="line">          .<span class="keyword">where</span>(<span class="string">&quot;id in (<span class="subst">$&#123;chunk.joinToString(<span class="string">&quot;,&quot;</span>) &#123; <span class="string">&quot;&#x27;<span class="variable">$it</span>&#x27;&quot;</span> &#125;</span>&#125;)&quot;</span>)</span><br><span class="line">          .execute()</span><br><span class="line">      &#125;</span><br><span class="line">      deletedCount += chunk.size</span><br><span class="line">      opCount += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><p>增加的逻辑在 cacheDataType 方法中，处理逻辑比较多，比较绕。其中包括了覆盖更新、追加更新两种。<br>从 <code>SqlProviderCache.kt</code> 的 cacheDataType() 进入 <code>SqlCache.kt</code> 的 mergeAll() 方法，便开始了新增逻辑。</p>
<ol>
<li>创建表。如果存在就忽略。</li>
<li>判断是否运用那种存储方式。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">storeResult</span> <span class="operator">=</span> <span class="keyword">if</span> (authoritative) &#123;</span><br><span class="line">  storeAuthoritative(type, agent, items, cleanup)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  storeInformative(type, items, cleanup)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>AUTHORITATIVE 和 INFORMATIVE 的区别</strong>：</p>
<ul>
<li>AUTHORITATIVE：操作资源表。它在更新表前，获取表名的方法为：resourceTableName(type)。</li>
<li>INFORMATIVE：操作 *_rel 表。它在更新表前，获取表名的方法为：relTableName(type)。</li>
</ul>
<p>它们通过 type 来获取表名的函数的实现分别为：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">resourceTableName</span><span class="params">(type: <span class="type">String</span>)</span></span>: String =</span><br><span class="line">  checkTableName(<span class="string">&quot;cats_v<span class="subst">$&#123;schemaVersion&#125;</span>_&quot;</span>, sanitizeType(type), <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">relTableName</span><span class="params">(type: <span class="type">String</span>)</span></span>: String =</span><br><span class="line">  checkTableName(<span class="string">&quot;cats_v<span class="subst">$&#123;schemaVersion&#125;</span>_&quot;</span>, sanitizeType(type), <span class="string">&quot;_rel&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>另外它们两，还有一个特性上的区别，如下(来自：AgentDataType.java)：</p>
<blockquote>
<p>If an agent is an Authoritative source of data, then it’s resulting data set will be considered the current complete set for that data source. If an agent is an Informative source of data, its results will contribute to the data set for that type, but is never considered the complete set of data, so will not result in deletions when elements are no longer present.</p>
</blockquote>
<h3 id="资源更新-AUTHORITATIVE"><a href="#资源更新-AUTHORITATIVE" class="headerlink" title="资源更新-AUTHORITATIVE"></a>资源更新-AUTHORITATIVE</h3><p>AUTHORITATIVE 的更新资源的逻辑如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从表中取出已经存在的信息，包括 body_hash 和 id</span></span><br><span class="line"><span class="keyword">val</span> existingHashIds = getHashIds(type, agent)</span><br><span class="line"><span class="comment">// 找出已存在信息的 id</span></span><br><span class="line"><span class="keyword">val</span> existingIds = existingHashIds</span><br><span class="line">      .asSequence()</span><br><span class="line">      .map &#123; it.id &#125;</span><br><span class="line">      .toSet()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入新的信息</span></span><br><span class="line"><span class="comment">// 代码过长，省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 id 删除已存在的信息</span></span><br><span class="line"><span class="keyword">if</span> (!cleanup) &#123;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> toDelete = existingIds</span><br><span class="line">  .asSequence()</span><br><span class="line">  .filter &#123; !currentIds.contains(it) &#125;</span><br><span class="line">  .toSet()</span><br><span class="line"></span><br><span class="line">evictAll(type, toDelete)</span><br></pre></td></tr></table></figure>
<p>可以看出来，cleanup 为 true 的时候，才会删除之前的信息，即 <strong>cleanup 为 true 才覆盖更新</strong>。</p>
<h3 id="关联资源更新-INFORMATIVE"><a href="#关联资源更新-INFORMATIVE" class="headerlink" title="关联资源更新-INFORMATIVE"></a>关联资源更新-INFORMATIVE</h3><p>此类型的 db 相关代码逻辑较绕，即函数 storeInformative(type, items, cleanup) 中，引入了很多变量，但通过命名揣测相应含义并不太可行，需要先行知晓一些概念。用到此类型的腾讯云 agent 如下：<br><img src="/images/pics/ddb502217d872041818db50a1e80f1ee.png"><br>外加一个 TencentLoadBalancerInstanceStateCachingAgent，它所实现的接口 HealthProvidingCachingAgent 引用了 INFORMATIVE，即：<br><img src="/images/pics/a450c8d39a92c45cc01952bb3148148e.png"><br>此处仅以 TencentLoadBalancerInstanceStateCachingAgent 为例，此 Agent 返回一个 AUTHORITATIVE 类型的 health，还有一个 INFORMATIVE 类型的 instances。health 不看，只看 instances，且直接到 storeInformative(type, items, cleanup)。</p>
<h4 id="Agent-返回的数据"><a href="#Agent-返回的数据" class="headerlink" title="Agent 返回的数据"></a>Agent 返回的数据</h4><p><img src="/images/pics/9b2406adf99536ae8c2de32f32a0c9f7.png"></p>
<h4 id="究竟干了啥"><a href="#究竟干了啥" class="headerlink" title="究竟干了啥"></a>究竟干了啥</h4><ol>
<li>操作了两张表，cats_v1_instances_rel 和 cats_v1_health_rel。</li>
<li>其中的数据分为两类，一类是 fwd 系，另外一类是 rev 系。可能是 forward 和 reverse 的缩写。在此处，fwd 系的数据全部来自 cats_v1_instances_rel；rev 系的数据全部来自 cats_v1_health_rel。代码如下：<br>fwd<br><img src="/images/pics/ef1575ce286b3cf7b7c3cef03f151f05.png"><br>rev<br><img src="/images/pics/3f1466c72abe3ec2f546469737576f3b.png"><br>它们调用的方法实现如下：<br><img src="/images/pics/ccbc8b869d20f1e62aaf8dbc07228d35.png"></li>
<li>由于操作了两张表，且对两张表的操作基本一致，所以对流程而言，可以只分析某一张表的操作逻辑。</li>
<li>其中对 fwd 系数据的操作如下：<ol>
<li>从 agent 返回的数据中挑选出新增的数据<br> <img src="/images/pics/f4a273650bf4fad6f6211ff3dd510f53.png"></li>
<li>插入新增数据<br> <img src="/images/pics/20c89e2051593a8e17ef592922d255f3.png"></li>
<li>删除失效数据（失效的定义：表中存在，但 agent 返回的数据中不存在）<br> <img src="/images/pics/b245c58eedab789fc651feecd7999660.png"></li>
</ol>
</li>
</ol>
<p>与 AUTHORITATIVE 相比，cleanup 仍然是决定是否删除先前数据的一个开关，但是可以看出：</p>
<ul>
<li>AUTHORITATIVE 是将 agent 返回的所有数据，全部插入表中，且在 cleanup 开关打开后，将之前所有的数据（即上一批插入的数据）删除。</li>
<li>INFORMATIVE 只将 agent 返回的新增数据（即之前表中不存在的数据）插入表中，且在 cleanup 开关打开后，将之前已失效的数据删除。</li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>1 | Spinnaker: Agent 缓存云厂商各项数据流程分析</p><p><a href="https://eucham.me/2020/07/30/20d4d0eeb1ae.html">https://eucham.me/2020/07/30/20d4d0eeb1ae.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>遇寻</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-07-30</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-04-20</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/clouddriver/">clouddriver</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=5f548d5caad6e60013d63db8&amp;product=inline-share-buttons" defer></script></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/08/02/d33b9db7e790.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">0 | kubernetes：学习路线导览与记录</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/07/30/3f3a2e801ffb.html"><span class="level-item">1 | Dubbo：探讨标签路由的实现</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://eucham.me/2020/07/30/20d4d0eeb1ae.html';
            this.page.identifier = '2020/07/30/20d4d0eeb1ae.html';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'eucham' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">十二月 2024</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">二月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/01/"><span class="level-start"><span class="level-item">一月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/06/"><span class="level-start"><span class="level-item">六月 2023</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">二月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/01/"><span class="level-start"><span class="level-item">一月 2023</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">十月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/08/"><span class="level-start"><span class="level-item">八月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">七月 2022</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">六月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">三月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">十月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/10/"><span class="level-start"><span class="level-item">十月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/02/"><span class="level-start"><span class="level-item">二月 2020</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/10/"><span class="level-start"><span class="level-item">十月 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/07/"><span class="level-start"><span class="level-item">七月 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/06/"><span class="level-start"><span class="level-item">六月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/05/"><span class="level-start"><span class="level-item">五月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/03/"><span class="level-start"><span class="level-item">三月 2019</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/02/"><span class="level-start"><span class="level-item">二月 2019</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/12/"><span class="level-start"><span class="level-item">十二月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/11/"><span class="level-start"><span class="level-item">十一月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">九月 2018</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">八月 2018</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/06/"><span class="level-start"><span class="level-item">六月 2018</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/05/"><span class="level-start"><span class="level-item">五月 2018</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/04/"><span class="level-start"><span class="level-item">四月 2018</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">三月 2018</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/02/"><span class="level-start"><span class="level-item">二月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/01/"><span class="level-start"><span class="level-item">一月 2018</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/12/"><span class="level-start"><span class="level-item">十二月 2017</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/10/"><span class="level-start"><span class="level-item">十月 2017</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/09/"><span class="level-start"><span class="level-item">九月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/03/"><span class="level-start"><span class="level-item">三月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/01/"><span class="level-start"><span class="level-item">一月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/12/"><span class="level-start"><span class="level-item">十二月 2016</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2024/12/09/249b2dc63505.html"><img src="/images/pics/5300c911560a8d2e0d745dcaf025d22f.jpg" alt="M系列MacBook连接l2tp时失败的问题修复"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-12-08T16:00:00.000Z">2024-12-09</time></p><p class="title"><a href="/2024/12/09/249b2dc63505.html">M系列MacBook连接l2tp时失败的问题修复</a></p><p class="categories"><a href="/categories/macOS/">macOS</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2024/12/09/e9036e8500f6.html"><img src="/images/thumbnails/rust-lang.png" alt="Rust学习笔记"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-12-08T16:00:00.000Z">2024-12-09</time></p><p class="title"><a href="/2024/12/09/e9036e8500f6.html">Rust学习笔记</a></p><p class="categories"><a href="/categories/Rust/">Rust</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2024/12/09/b0874d97f2ec.html"><img src="/images/pics/8a16be7bbc191e48a6e5b08755f591ec.png" alt="01.AI概览"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-12-08T16:00:00.000Z">2024-12-09</time></p><p class="title"><a href="/2024/12/09/b0874d97f2ec.html">01.AI概览</a></p><p class="categories"><a href="/categories/AI/">AI</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2024/12/09/4948e86c1262.html"><img src="/images/pics/DrRvr9.jpg" alt="Calico证书学习笔记"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-12-08T16:00:00.000Z">2024-12-09</time></p><p class="title"><a href="/2024/12/09/4948e86c1262.html">Calico证书学习笔记</a></p><p class="categories"><a href="/categories/Kubernetes/">Kubernetes</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2024/12/09/6dae87e31dc3.html"><img src="/images/pics/e9f22d889a230bfda8e24c0a981740a8.png" alt="如何在YAML文件中进行优雅地换行"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-12-08T16:00:00.000Z">2024-12-09</time></p><p class="title"><a href="/2024/12/09/6dae87e31dc3.html">如何在YAML文件中进行优雅地换行</a></p><p class="categories"><a href="/categories/Golang/">Golang</a></p></div></article></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://crisfang.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Cris</span></span><span class="level-right"><span class="level-item tag">crisfang.com</span></span></a></li><li><a class="level is-mobile" href="https://sanyuesha.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">三月沙</span></span><span class="level-right"><span class="level-item tag">sanyuesha.com</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/pics/d261cdb6203e0da42ae1324dd3aae11f.png" alt="遇寻笔记" height="28"></a><p class="is-size-7"><span>&copy; 2024 遇寻</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="To Find Me" href="https://github.com/eucham"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="LinkedIn" href="https://www.linkedin.com/in/eucham"><i class="fab fa-linkedin"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"></script><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>