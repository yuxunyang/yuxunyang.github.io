<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>遇寻笔记</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="遇寻笔记"><meta name="msapplication-TileImage" content="/images/pics/d261cdb6203e0da42ae1324dd3aae11f.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="遇寻笔记"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="No. I&amp;#39;ll bring me back a souvenir."><meta property="og:type" content="website"><meta property="og:title" content="遇寻笔记"><meta property="og:url" content="https://eucham.me/"><meta property="og:site_name" content="遇寻笔记"><meta property="og:description" content="No. I&amp;#39;ll bring me back a souvenir."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://eucham.me/img/og_image.png"><meta property="article:author" content="遇寻"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://eucham.me"},"headline":"遇寻笔记","image":["https://eucham.me/img/og_image.png"],"author":{"@type":"Person","name":"遇寻"},"publisher":{"@type":"Organization","name":"遇寻笔记","logo":{"@type":"ImageObject","url":"https://eucham.me/images/pics/d261cdb6203e0da42ae1324dd3aae11f.png"}},"description":"No. I&#39;ll bring me back a souvenir."}</script><link rel="icon" href="/images/pics/d261cdb6203e0da42ae1324dd3aae11f.png"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?7d79380bb26079f6dd33da78e83cf2ab";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/images/pics/d261cdb6203e0da42ae1324dd3aae11f.png" alt="遇寻笔记" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/categories/AI">AI</a><a class="navbar-item" href="/categories/Kubernetes">Kubernetes</a><a class="navbar-item" href="/categories/Openstack">Openstack</a><a class="navbar-item" href="/categories/Docker">Container</a><a class="navbar-item" href="/categories/Golang">Golang</a><a class="navbar-item" href="/categories/Rust">Rust</a><a class="navbar-item" href="/about.html">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="To Find Me" href="https://github.com/eucham"><i class="fab fa-github"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="LinkedIn" href="https://www.linkedin.com/in/eucham"><i class="fab fa-linkedin"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-03-12T15:35:56.000Z" title="3/12/2020, 11:35:56 PM">2020-03-12</time>发表</span><span class="level-item"><time dateTime="2022-04-20T16:25:45.452Z" title="4/21/2022, 12:25:45 AM">2022-04-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Spring%E7%B3%BB%E5%88%97/">Spring系列</a></span><span class="level-item">11 分钟读完 (大约1615个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/03/12/4c4e3782503c.html">1 | SpringCloud：nacos从入门到出门</a></h1><div class="content">nacos可提供动态服务发现、服务配置、服务元数据及流量管理。nacos集群搭建下载nacos：https://github.com/alibaba/nacos/releases/download/1.2.0/nacos-server-1.2.0.zip解压修改startup.cmd中的MODE为c</div><a class="article-more button is-small is-size-7" href="/2020/03/12/4c4e3782503c.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-03-11T14:59:55.000Z" title="3/11/2020, 10:59:55 PM">2020-03-11</time>发表</span><span class="level-item"><time dateTime="2021-02-09T03:04:05.798Z" title="2/9/2021, 11:04:05 AM">2021-02-09</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span><span class="level-item">14 分钟读完 (大约2159个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/03/11/b04a730e5e11.html">6 | Netty：新连接的建立</a></h1><div class="content"><p><img src="https://netty.io/images/logo.png"></p>
<blockquote>
<p> 当服务端启动好了之后，也就是说，服务端已经在执行<code>NioEventLoop</code>的一个死循环方法<code>run()</code>中，一直轮询事件，并且此时的监听的事件为<code>OP_ACCEPT</code>。如果有新连接接入，那么首先会在上述的<code>run()</code>方法中触发…</p>
</blockquote>
<h2 id="收到新的连接"><a href="#收到新的连接" class="headerlink" title="收到新的连接"></a>收到新的连接</h2><p>首先，服务端启动好了之后，会进入等待事件的状态，也就是调用JDK的NIO的API：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NioEventLoop.java -&gt; run()</span></span><br><span class="line"><span class="keyword">if</span> (!hasTasks()) &#123;</span><br><span class="line">		strategy = select(curDeadlineNanos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 核心是调用jdk的api</span></span><br><span class="line">selector.select();</span><br></pre></td></tr></table></figure>

<p>收到新的连接后，将会通过<code>processSelectedKeys()</code>进行处理，处理内容包括：创建、初始化<code>NioSocketChannel</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NioEventLoop.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (selectedKeys != <span class="keyword">null</span>) &#123;</span><br><span class="line">        processSelectedKeysOptimized();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeysOptimized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; selectedKeys.size; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> SelectionKey k = selectedKeys.keys[i];</span><br><span class="line">        <span class="comment">// 帮助GC</span></span><br><span class="line">        selectedKeys.keys[i] = <span class="keyword">null</span>;</span><br><span class="line">				<span class="comment">// attachment是NioServerSocketChannel</span></span><br><span class="line">      	<span class="comment">// 服务端注册selectionKey时传入</span></span><br><span class="line">        <span class="keyword">final</span> Object a = k.attachment();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">          	<span class="comment">// 此处真正进入处理新连接事件</span></span><br><span class="line">            processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line">            processSelectedKey(k, task);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">// 此时的readyOps为OP_ACCEPT，也就是16，即二进制10000</span></span><br><span class="line">        <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理新连接的逻辑开始</span></span><br><span class="line">      	<span class="comment">// SelectionKey.OP_READ | SelectionKey.OP_ACCEPT = 10001</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">          	<span class="comment">// 此处的unsafe与创建连接时的unsafe不是同一个实现</span></span><br><span class="line">            unsafe.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建、初始化NioSocketChannel"><a href="#创建、初始化NioSocketChannel" class="headerlink" title="创建、初始化NioSocketChannel"></a>创建、初始化NioSocketChannel</h2><p>上面的unsafe的具体实现是在一个叫做<code>NioMessageUnsafe</code>的内部类中，在它的read方法中：</p>
<p>①创建了<code>NioSocketChannel</code>。②通过pipeline中的Handler，即ServerBootstrap$ServerBootstrapAcceptor中初始化NioSocketChannel。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">eventLoop</span><span class="params">()</span>.<span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line">    Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">              	<span class="comment">// ①创建了NioSocketChannel,并加入到readBuf这个List中</span></span><br><span class="line">                <span class="keyword">int</span> localRead = doReadMessages(readBuf);</span><br><span class="line">                <span class="keyword">if</span> (localRead == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (localRead &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    closed = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                allocHandle.incMessagesRead(localRead);</span><br><span class="line">            &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            exception = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = readBuf.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">            readPending = <span class="keyword">false</span>;</span><br><span class="line">          	<span class="comment">// ②在ServerBootstrap$ServerBootstrapAcceptor中初始化NioSocketChannel</span></span><br><span class="line">            pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        readBuf.clear();</span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>创建NioSocketChannel的主要流程，就是先通过调用JDK的API获取SocketChannel，然后再将其作为一个值传给NioSocketChannel。因此从另一个方面来看，可以理解成NioSocketChannel是SocketChannel的封装。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  	<span class="comment">// 实际调用时serverSocketChannel.accept()  </span></span><br><span class="line">  	SocketChannel ch = SocketUtils.accept(javaChannel());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// 创建NioSocketChannel</span></span><br><span class="line">            buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>主要依靠pipeline中的相应事件传递。比如说，将channel注册到EventLoop中这个事件，就是靠pipeline中的Handler，ServerBootstrapAcceptor来完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用pipeline中的不可覆盖方法fireChannelRead</span></span><br><span class="line">pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与之前的流程类似，从pipeline中的头handler开始传递事件</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext.invokeChannelRead(head, msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个静态模板方法，掉用next的invokeChannelRead()方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>), next);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelRead(m);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                next.invokeChannelRead(m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还是一个模板方法，用于真实执行hander的read事件处理方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          	<span class="comment">// 触发handler的read事件，模板模式</span></span><br><span class="line">            ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            notifyHandlerException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fireChannelRead(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，事件的往后续handler传递，都是调用上面的这个两个方法，来执行后续handler的相应read方法。此时pipeline中的handler有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) DefaultChannelPipeline$HeadContext</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>) io.netty.handler.logging.LoggingHandler</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>) io.netty.bootstrap.ServerBootstrap$ServerBootstrapAcceptor</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>) DefaultChannelPipeline$TailContext</span><br></pre></td></tr></table></figure>

<p>其中，head对read只是做简单的传递：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultChannelPipeline$HeadContext</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    ctx.fireChannelRead(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractChannelHandlerContext.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireChannelRead</span><span class="params">(<span class="keyword">final</span> Object msg)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 调用上面代码片段中的静态模板方法，实现事件传递</span></span><br><span class="line">    invokeChannelRead(findContextInbound(MASK_CHANNEL_READ), msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对<code>LoggingHandler</code>而言，简易打印日志，并往后传递事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LoggingHandler.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isEnabled(internalLevel)) &#123;</span><br><span class="line">        logger.log(internalLevel, format(ctx, <span class="string">&quot;READ&quot;</span>, msg));</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.fireChannelRead(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到<code>ServerBootstrapAcceptor</code>的read方法时，初始化便真正地开始了（此时的线程为bossGroup中的EventLoop）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServerBootstrapAcceptor</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line">		<span class="comment">// 将ChannelInitializer添加到pipeline中，等执行完initial方法后，会被移除</span></span><br><span class="line">    child.pipeline().addLast(childHandler);</span><br><span class="line">		<span class="comment">// 设置NioSocketChannel属性</span></span><br><span class="line">    setChannelOptions(child, childOptions, logger);</span><br><span class="line">    setAttributes(child, childAttrs);</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">// 将NioSocketChannel绑定到一个workGroup中的NioEventLoop上</span></span><br><span class="line">        childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                    forceClose(child, future.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        forceClose(child, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>register的过程与服务端启动时的绑定类似，先选出一个EventLoop，选的时候，有两种方式，根据不同的线程数，使用不同的选择方式。然后经过辗转，来到对<code>register0()</code>的执行，这个方法时主要的register操作。但是此时的线程是bossGroup中的EventLoop，而<code>register0()</code>会在workGroup中的线程中执行。所以会先将task放入队列中，然后启动线程，并进入NioEventLoop的run()死循环方法，通过不断遍历是否有已监听事件以及执行队列中的任务，最终来执行该task。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MultithreadEventLoopGroup.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> next().register(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SingleThreadEventLoop.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> register(<span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">&quot;promise&quot;</span>);</span><br><span class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractChannel.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line">  	<span class="comment">// 此时的线程是bossGroup中的EventLoop，</span></span><br><span class="line">  	<span class="comment">// 此处的eventLoop则为上面分配的wordGroup中的线程。</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">// 所以会执行此方法，此时该eventLoop中的线程还未启动，会将此task放入队列中</span></span><br><span class="line">      	<span class="comment">// 然后会通过eventLoop.execute来启动线程，并进入NioEventLoop的run()方法</span></span><br><span class="line">      	<span class="comment">// 通过不断遍历是否有已监听事件以及执行队列中的任务，最终来执行该task。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，线程切换到workGroup中的EventLoop。主要执行好几个操作：先调用jdk的api，注册selectionKey；再发布相应的事件；最后修改interestOps为OP_READ。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">      	<span class="comment">// 调用jdk的api，注册selectionKey</span></span><br><span class="line">        doRegister();</span><br><span class="line">        neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">        registered = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理ChannelInitializer，并移除掉它</span></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">				<span class="comment">// 在服务端启动的时候，会以观察者模式调用操作完成的Listener</span></span><br><span class="line">      	<span class="comment">// doBind操作就是这样被封装到了其中，但处理客户端连接没有doBind操作</span></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">      	<span class="comment">// 从pipeline的head开始传递registered事件</span></span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        <span class="comment">// 此时已经被激活</span></span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">          	<span class="comment">// 第一次进行register操作，被视为建立连接</span></span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">              	<span class="comment">// 与服务端类似，会在此处将监听的事件改为OP_READ</span></span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                <span class="comment">// 真的有数据来了</span></span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用jdk的api，注册selectionKey</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractNioChannel.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          	<span class="comment">// 监听的事件为0，attachment是channel自己</span></span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对channle已激活的事件传递中，会将NioSocketChannel的interestOps修改为OP_READ。下面的代码是事件在pipeline中的传递，与上面的分析内容一致，在此不多赘述。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultChannelPipeline.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext.invokeChannelActive(head);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractChannelHandlerContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelActive</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next)</span> </span>&#123;</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelActive();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                next.invokeChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((ChannelInboundHandler) handler()).channelActive(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            notifyHandlerException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>唯一有区别的是：pipeline中的head，即HeadContext对active事件的处理方式，多了一块对interestOps的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultChannelPipeline.java $ HeadContext</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    ctx.fireChannelActive();</span><br><span class="line">  	<span class="comment">// 修改interestOps</span></span><br><span class="line">    readIfIsAutoRead();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readIfIsAutoRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (channel.config().isAutoRead()) &#123;</span><br><span class="line">        channel.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会在pipeline中传递read事件，但是是从tail开始，可以直接跳到TailContext的read()方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractChannel.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Channel <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pipeline.read();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultChannelPipeline.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tail.read();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractChannelHandlerContext.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound(MASK_READ);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeRead();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Tasks tasks = next.invokeTasks;</span><br><span class="line">        <span class="keyword">if</span> (tasks == <span class="keyword">null</span>) &#123;</span><br><span class="line">            next.invokeTasks = tasks = <span class="keyword">new</span> Tasks(next);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.execute(tasks.invokeReadTask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((ChannelOutboundHandler) handler()).read(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            notifyHandlerException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultChannelPipeline.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    unsafe.beginRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处便到了修改的interestOps的主要逻辑处：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractChannel.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">beginRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isActive()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doBeginRead();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pipeline.fireExceptionCaught(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        close(voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractNioChannel.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">    <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line">    <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readPending = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">  	<span class="comment">// 此时interestOps为0，所以if中的条件一定会成立</span></span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，对新建连接的处理基本完成。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-02-27T17:56:36.000Z" title="2/28/2020, 1:56:36 AM">2020-02-28</time>发表</span><span class="level-item"><time dateTime="2021-02-09T03:03:57.708Z" title="2/9/2021, 11:03:57 AM">2021-02-09</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span><span class="level-item">34 分钟读完 (大约5093个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/28/001684b38465.html">5 | Netty：服务端启动流程分析</a></h1><div class="content"><p><img src="https://netty.io/images/logo.png"></p>
<blockquote>
<p>目前对于Netty的理解是：一套完善了Java NIO操作的框架，因为Netty的最底层还是调用jdk的nio相关的API，但是又在jdk的nio基础上做了很多的封装，并衍生出来了自己相关的概念。</p>
</blockquote>
<h2 id="服务启动的主线操作"><a href="#服务启动的主线操作" class="headerlink" title="服务启动的主线操作"></a>服务启动的主线操作</h2><p>以<code>EchoServer</code>为例，一条可参考的服务启动的主线操作如下：</p>
<p><strong>main thread</strong></p>
<ol>
<li>创建selector</li>
<li>创建serversocketchannel</li>
<li>初始化serversocketchannel</li>
<li>给serversocketchannel从bossgroup中选择一个NioEventLoop</li>
</ol>
<p><strong>boss thread</strong></p>
<ol>
<li>将serversocketchannel注册到选择的NioEventLoop的selector</li>
<li>绑定地址启动</li>
<li>注册接受连接事件(OP_ACCEPT)到selector上</li>
</ol>
<p>对应到代码中的操作依次为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建selector</span></span><br><span class="line">Selector selector = sun.nio.ch.SelectorProviderImpl.openSelector();</span><br><span class="line"><span class="comment">// 2. 创建serversocketchannel</span></span><br><span class="line">ServerSocketChannel serverSocketChannel = provider.openServerSocketChannel();</span><br><span class="line"><span class="comment">// 将serversocketchannel注册到选择的NioEventLoop的selector</span></span><br><span class="line">selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>); </span><br><span class="line"><span class="comment">// 绑定地址启动</span></span><br><span class="line">javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line"><span class="comment">// 注册接受连接事件(OP_ACCEPT)到selector上</span></span><br><span class="line">selectionKey.interestOps(OP_ACCEPT);</span><br></pre></td></tr></table></figure>

<p>根据上面的启动主线，以它为一个参考，我觉得这个主线过于简略，也就是说很多操作并不能体现出来。所以我将创建一个server的步骤分成如下3个大的步骤。下面会对上述3个大步骤做适当、尽可能详细的分析，并将之前看过的源码内容与服务创建联系起来。</p>
<h2 id="创建EventLoopGroup"><a href="#创建EventLoopGroup" class="headerlink" title="创建EventLoopGroup"></a>创建<code>EventLoopGroup</code></h2><p><code>EventLoopGroup</code>的个数决定具体reactor模式，在<code>EchoServer</code>中使用了两个<code>EventLoopGroup</code>，也就是使用了<strong>主从Reactor多线程模式</strong>；而<code>EventLoopGroup</code>的类型决定使用的IO模式，这里使用的是``NioEventLoopGroup<code>也就是使用的IO模式为NIO。对应于</code>EchoServer`中的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br></pre></td></tr></table></figure>

<p>到这里有若干个问题，但是主线中不会提及，因为主线关注的是操作链条，在大致了解主线操作之后，加强对个各个细节处的理解，才能理解得更加透彻。这里的问题主要来自心中的疑问。</p>
<h3 id="什么是EventLoopGroup、EventLoop"><a href="#什么是EventLoopGroup、EventLoop" class="headerlink" title="什么是EventLoopGroup、EventLoop"></a>什么是<code>EventLoopGroup</code>、<code>EventLoop</code></h3><p>之前的初略理解是：<code>EventLoopGroup</code>是一个线程池、<code>EventLoop</code>则对应一个线程。</p>
<p><code>EventLoopGroup</code>是一个接口，有多种实现方式，在<code>EchoServer</code>中，它的实现是<code>NioEventLoopGroup</code>。</p>
<p><img src="/images/pics/16a6527c908cfc13af90746fbebb1594.png"></p>
<p><code>Channel</code>、<code>EventLoop</code>、<code>EventLoopGroup</code>之间的关系如下图所示：</p>
<p><img src="/images/pics/9d86875377fae4b74bdf3d89d06a8faa.png"></p>
<ul>
<li><p>一个<code>EventLoopGroup</code>包含一个或者多个<code>EventLoop</code>；</p>
</li>
<li><p>一个<code>EventLoop</code>在它的生命周期内只和一个<code>Thread</code>绑定；</p>
</li>
<li><p>所有由<code>EventLoop</code>处理的I/O事件都将在它专有的<code>Thread</code>上被处理；</p>
</li>
<li><p>一个<code>Channel</code>在它的生命周期内只注册于一个<code>EventLoop</code>；</p>
</li>
<li><p>一个<code>EventLoop</code>可能会被分配给一个或多个<code>Channel</code>。</p>
</li>
</ul>
<h3 id="为什么new-NioEventLoopGroup-1-传1"><a href="#为什么new-NioEventLoopGroup-1-传1" class="headerlink" title="为什么new NioEventLoopGroup(1)传1"></a>为什么<code>new NioEventLoopGroup(1)</code>传1</h3><p>在前面的一篇文章中有分析过为什么传1，因为对于boss group来说，只会有一个channel，所以只绑定1个线程，也就只需要1个<code>EventLoop</code>。</p>
<p>如果不传任何参数，线程数在<code>NioEventLoopGroup</code>中会先传0，在父类<code>MultithreadEventLoopGroup</code>先再做判断，如果为0，那么会默认为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(</span><br><span class="line">                <span class="string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取SelectorProvider"><a href="#获取SelectorProvider" class="headerlink" title="获取SelectorProvider"></a>获取SelectorProvider</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在NioEventLoopGroup.java中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>(<span class="number">0</span>, threadFactory, SelectorProvider.provider());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在SelectorProvider.java中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">provider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (provider != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> provider;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedAction&lt;SelectorProvider&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> SelectorProvider <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (loadProviderFromProperty())</span><br><span class="line">                        <span class="keyword">return</span> provider;</span><br><span class="line">                    <span class="keyword">if</span> (loadProviderAsService())</span><br><span class="line">                        <span class="keyword">return</span> provider;</span><br><span class="line">                    provider = sun.nio.ch.DefaultSelectorProvider.create();</span><br><span class="line">                    <span class="keyword">return</span> provider;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>sun.nio.ch.DefaultSelectorProvider</code>在不同平台jdk中、其实现不一样，从而以此达到，统一不同平台下<code>Selector</code>的实现。其中Windows下的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSelectorProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DefaultSelectorProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WindowsSelectorProvider();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="根据线程数创建EventExecutor数组并初始化"><a href="#根据线程数创建EventExecutor数组并初始化" class="headerlink" title="根据线程数创建EventExecutor数组并初始化"></a>根据线程数创建<code>EventExecutor</code>数组并初始化</h3><p>在<code>MultithreadEventExecutorGroup</code>的构造函数中，会初始化一个<code>EventExecutor</code>数组，其实这就是<code>NioEventLoop</code>数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        children[i] = newChild(executor, args);</span><br><span class="line">        success = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Think about if this is a good exception type</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;failed to create a child event loop&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// 创建EventLoopGroup失败，释放资源</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// chooserFactory是用来创建一个选择器的工厂类。</span></span><br><span class="line">chooser = chooserFactory.newChooser(children);</span><br></pre></td></tr></table></figure>

<p>选择器是用来选择一个<code>EventLoop</code>，供进行事件处理。具体有两种策略，一种是EventLoop个数为2的倍数（通过&amp;运算）、一种是普通的（通过%运算）。说真的，我对这两者的差异没有啥感觉。</p>
<p>对于<code>newChild()</code>这个方法，我们找到对应的<code>NioEventLoopGroup</code>的实现：</p>
<p><img src="/images/pics/0d514b25218bc0b70735a871010967fa.png"></p>
<p>也就是说，在初始化<code>NioEventLoopGroup</code>的时候，就已经将所有的<code>NioEventLoop</code>初始化完成。</p>
<h3 id="NioEventLoop的初始化"><a href="#NioEventLoop的初始化" class="headerlink" title="NioEventLoop的初始化"></a>NioEventLoop的初始化</h3><ol>
<li><p>打开<code>openSelector()</code>操作。说明selector在初始化<code>NioEventLoop</code>时就被打开。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> SelectorTuple selectorTuple = openSelector();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> SelectorTuple <span class="title">openSelector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Selector unwrappedSelector;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        unwrappedSelector = provider.openSelector();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">&quot;failed to open a new selector&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化一个包装Runnable后的executor。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.executor = ThreadExecutorMap.apply(executor, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Executor <span class="title">apply</span><span class="params">(<span class="keyword">final</span> Executor executor, <span class="keyword">final</span> EventExecutor eventExecutor)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(executor, <span class="string">&quot;executor&quot;</span>);</span><br><span class="line">    ObjectUtil.checkNotNull(eventExecutor, <span class="string">&quot;eventExecutor&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Executor() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable command)</span> </span>&#123;</span><br><span class="line">            executor.execute(apply(command, eventExecutor));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 包装Runnable后，再返回一个包装后的Runnable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runnable <span class="title">apply</span><span class="params">(<span class="keyword">final</span> Runnable command, <span class="keyword">final</span> EventExecutor eventExecutor)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(command, <span class="string">&quot;command&quot;</span>);</span><br><span class="line">    ObjectUtil.checkNotNull(eventExecutor, <span class="string">&quot;eventExecutor&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            setCurrentEventExecutor(eventExecutor);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                command.run();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                setCurrentEventExecutor(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="通过Bootstrap设置相关参数"><a href="#通过Bootstrap设置相关参数" class="headerlink" title="通过Bootstrap设置相关参数"></a>通过<code>Bootstrap</code>设置相关参数</h2><h2 id="绑定端口并启动"><a href="#绑定端口并启动" class="headerlink" title="绑定端口并启动"></a>绑定端口并启动</h2><p>这一步骤有多个重要的过程。</p>
<h4 id="创建NioServerSocketChannel"><a href="#创建NioServerSocketChannel" class="headerlink" title="创建NioServerSocketChannel"></a>创建<code>NioServerSocketChannel</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定channel类型为NioServerSocketChannel</span></span><br><span class="line">b.group(bossGroup, workerGroup)</span><br><span class="line">	.channel(NioServerSocketChannel.class)</span><br><span class="line"><span class="comment">// 设置一个生成channel的工厂类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> ReflectiveChannelFactory&lt;C&gt;(</span><br><span class="line">            ObjectUtil.checkNotNull(channelClass, <span class="string">&quot;channelClass&quot;</span>)</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channelFactory</span><span class="params">(io.netty.channel.ChannelFactory&lt;? extends C&gt; channelFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> channelFactory((ChannelFactory&lt;C&gt;) channelFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channelFactory</span><span class="params">(ChannelFactory&lt;? extends C&gt; channelFactory)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(channelFactory, <span class="string">&quot;channelFactory&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.channelFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;channelFactory set already&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 后续channel由channleFactory产生</span></span><br><span class="line">    <span class="keyword">this</span>.channelFactory = channelFactory;</span><br><span class="line">    <span class="keyword">return</span> self();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处的<code>channelFactory</code>是一个<code>ReflectiveChannelFactory</code>，它的实现比较简单，<strong>通过class获取到构造器，然后通过构造器即可创建出新的对象</strong>。简单的逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReflectiveChannelFactory</span><span class="params">(Class&lt;? extends T&gt; clazz)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(clazz, <span class="string">&quot;clazz&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.constructor = clazz.getConstructor();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化完<code>channelFactory</code>之后，进入<code>doBind()</code>阶段，此时会通过一个<code>channelFactory</code>来创建一个新的对象，即<code>NioServerSocketChannel</code>。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	channel = channelFactory.newChannel();</span><br><span class="line">    	<span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>NioServerSocketChannel</code>创建的时候，会创建一个<code>ServerSocketChannel</code>，调用栈依次为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SelectorProvider.provider()可参见前文中的内容</span></span><br><span class="line">SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">    config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioMessageChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent, ch, readInterestOp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="keyword">this</span>.ch = ch;</span><br><span class="line">    <span class="keyword">this</span>.readInterestOp = readInterestOp;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ch.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    id = newId();</span><br><span class="line">    unsafe = newUnsafe();</span><br><span class="line">    <span class="comment">// 添加一个默认的pipeline，类型为DefaultChannelPipeline</span></span><br><span class="line">    pipeline = newChannelPipeline();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DefaultChannelPipeline <span class="title">newChannelPipeline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPipeline(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="初始化刚创建的NioServerSocketChannel"><a href="#初始化刚创建的NioServerSocketChannel" class="headerlink" title="初始化刚创建的NioServerSocketChannel"></a>初始化刚创建的NioServerSocketChannel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        init(channel);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>init()</code>中，主要是给新创建的<code>NioServerSocketChannel</code>设置参数，然后在它的pipeline上面添加一个<code>ChannelHandler</code>，用来处理新建立的连接，也就是<code>ServerBootstrapAcceptor</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 此处的执行p.addLast时，因为channel还未注册到eventloop上，</span></span><br><span class="line">    <span class="comment">// 所以会将这个ChannelInitializer保存到ctx中，</span></span><br><span class="line">    <span class="comment">// 并将ctx封装成一个PendingHandlerAddedTask，添加到pipeline中，</span></span><br><span class="line">    <span class="comment">// 等待注册到eventloop后触发</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>p.addLast()</code>执行的时候，如果当前channel，即<code>NioServerSocketChannel</code>，没有注册到一个EventLoop，那么将会以<code>PendingHandlerCallback</code>的形式，保存到pipeline的<code>pengdingHandlerCallbackHead</code>这个链表上。</p>
<p><img src="/images/pics/d18ccbdff8c564ef3282333b85e23d5e.png"></p>
<p>其中<code>PendingHandlerCallback</code>可以简单理解成：只是一个保存有<code>AbstractChannelHandlerContext</code>的<code>Runnable</code>，并且具有单向链表结构。它的设计目的，就是等待某个时候被执行。</p>
<h4 id="注册channel到eventloop"><a href="#注册channel到eventloop" class="headerlink" title="注册channel到eventloop"></a>注册channel到eventloop</h4><p>从<code>ChannelFuture regFuture = config().group().register(channel);</code>开始，一路可以追踪到<code>AbstractChannel</code>的<code>register</code>方法里面。刚开始有一段状态判断的代码，这段代码可以印证前面的一个说法：<strong>一个channel只能注册到一个eventloop</strong>。</p>
<p><img src="/images/pics/bb358e55a13f792bc80bff438dd3decb.png"></p>
<p>接着在eventLoop的线程中执行<code>register0()</code>方法，也就是说main线程开始返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 紧接上面的代码</span></span><br><span class="line"><span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">    register0(promise);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                register0(promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，<code>initAndRegister()</code>返回之后会拿到一个ChannelFuture，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        init(channel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在eventLoop中执行<code>register0()</code>完毕，那么将继续执行<code>doBind0()</code>，在main线程中；如果没执行完毕，会等<code>register0()</code>在eventLoop中执行完毕之后，再执行<code>doBind0()</code>，此时的线程是eventLoop。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        ChannelPromise promise = channel.newPromise();</span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">              	<span class="comment">//...</span></span><br><span class="line">                doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，<code>EchoServer</code>中<code>ChannelFuture f = b.bind(PORT).sync()</code>中的<code>b.bind(PORT)</code>在main线程中的操作已经完成。所以当前步骤又分成了两个，即：1. register0；2. doBind0。</p>
<h5 id="1-register0"><a href="#1-register0" class="headerlink" title="1. register0"></a>1. register0</h5><p>此函数关键操作的流程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractChannel.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      	<span class="comment">// 一个由子类继承的方法，这里是AbstractNioChannel的实现，即：</span></span><br><span class="line">      	<span class="comment">// selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);</span></span><br><span class="line">        doRegister();</span><br><span class="line">        neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">      	<span class="comment">// channel变成已注册到EventLoop，若该channel再注册到其他EventLoop会失败。</span></span><br><span class="line">        registered = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行之前未绑定EventLoop时，添加的PendingHandlerCallback</span></span><br><span class="line">      	<span class="comment">// 详细可以参考下面的执行PendingHandlerCallback的流程</span></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">				</span><br><span class="line">      	<span class="comment">// 此方法在设置了promise的执行状态后，再通过观察者模式，</span></span><br><span class="line">      	<span class="comment">// 通知所有的ChannelFutureListener，也就是会接着执行doBind0()。</span></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        <span class="comment">// Only fire a channelActive if the channel has never been registered. This prevents firing</span></span><br><span class="line">        <span class="comment">// multiple channel actives if the channel is deregistered and re-registered.</span></span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                <span class="comment">// This channel was registered before and autoRead() is set. This means we need to begin read</span></span><br><span class="line">                <span class="comment">// again so that we process inbound data.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// See https://github.com/netty/netty/issues/4805</span></span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// Close the channel directly to avoid FD leak.</span></span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="执行PendingHandlerCallback的流程"><a href="#执行PendingHandlerCallback的流程" class="headerlink" title="执行PendingHandlerCallback的流程"></a>执行PendingHandlerCallback的流程</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultChannelPipeline.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invokeHandlerAddedIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> channel.eventLoop().inEventLoop();</span><br><span class="line">    <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">        firstRegistration = <span class="keyword">false</span>;</span><br><span class="line">      	<span class="comment">// 已将Channel注册到EventLoop，现在开始执行handlerAdded这个回调。</span></span><br><span class="line">        callHandlerAddedForAllHandlers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultChannelPipeline.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callHandlerAddedForAllHandlers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> PendingHandlerCallback pendingHandlerCallbackHead;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">assert</span> !registered;</span><br><span class="line">        <span class="comment">// 设置已注册的标志位</span></span><br><span class="line">        registered = <span class="keyword">true</span>;</span><br><span class="line">      	<span class="comment">// 获取之前的pendingHandlerCallbackHead， 并将其置null</span></span><br><span class="line">        pendingHandlerCallbackHead = <span class="keyword">this</span>.pendingHandlerCallbackHead;</span><br><span class="line">        <span class="comment">// 方便GC</span></span><br><span class="line">        <span class="keyword">this</span>.pendingHandlerCallbackHead = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This must happen outside of the synchronized(...) block as otherwise handlerAdded(...) may be called while</span></span><br><span class="line">    <span class="comment">// holding the lock and so produce a deadlock if handlerAdded(...) will try to add another handler from outside</span></span><br><span class="line">    <span class="comment">// the EventLoop.</span></span><br><span class="line">    PendingHandlerCallback task = pendingHandlerCallbackHead;</span><br><span class="line">  	<span class="comment">// 依次遍历执行所有的pendingHandlerCallback</span></span><br><span class="line">    <span class="keyword">while</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">        task.execute();</span><br><span class="line">        task = task.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PendingHandlerAddedTask</code>的结构在前面已有描述，这里补充一下它的代码实现。其实<code>task.execute();</code>最终执行的代码是<code>callHandlerAdded0(ctx)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultChannelPipeline.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PendingHandlerCallback</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存ctx</span></span><br><span class="line">  	<span class="keyword">final</span> AbstractChannelHandlerContext ctx;</span><br><span class="line">  	<span class="comment">// 单向链表</span></span><br><span class="line">    PendingHandlerCallback next;</span><br><span class="line">    PendingHandlerCallback(AbstractChannelHandlerContext ctx) &#123;</span><br><span class="line">        <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PendingHandlerAddedTask</span> <span class="keyword">extends</span> <span class="title">PendingHandlerCallback</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        callHandlerAdded0(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EventExecutor executor = ctx.executor();</span><br><span class="line">      	<span class="comment">// 此时执行的线程是eventLoop</span></span><br><span class="line">        <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">            callHandlerAdded0(ctx);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                executor.execute(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                atomicRemoveFromHandlerList(ctx);</span><br><span class="line">                ctx.setRemoved();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完<code>ChanneInitializer</code>之后，将其从pipeline中移除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultChannelPipeline.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callHandlerAdded0</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ctx.callHandlerAdded();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            atomicRemoveFromHandlerList(ctx);</span><br><span class="line">            ctx.callHandlerRemoved();</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractChannelHandlerContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">callHandlerAdded</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// We must call setAddComplete before calling handlerAdded. Otherwise if the handlerAdded method generates</span></span><br><span class="line">    <span class="comment">// any pipeline events ctx.handler() will miss them because the state will not allow it.</span></span><br><span class="line">    <span class="comment">// 上述注释存疑，可待后续分析</span></span><br><span class="line">  	<span class="keyword">if</span> (setAddComplete()) &#123;</span><br><span class="line">      	<span class="comment">// handler在此处即ChannelInitialzer</span></span><br><span class="line">        handler().handlerAdded(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChannelInitialzer.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.channel().isRegistered()) &#123;</span><br><span class="line">        <span class="comment">// This should always be true with our current DefaultChannelPipeline implementation.</span></span><br><span class="line">        <span class="comment">// The good thing about calling initChannel(...) in handlerAdded(...) is that there will be no ordering</span></span><br><span class="line">        <span class="comment">// surprises if a ChannelInitializer will add another ChannelInitializer. This is as all handlers</span></span><br><span class="line">        <span class="comment">// will be added in the expected order.</span></span><br><span class="line">        <span class="keyword">if</span> (initChannel(ctx)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We are done with init the Channel, removing the initializer now.</span></span><br><span class="line">            removeState(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initMap.add(ctx)) &#123; <span class="comment">// Guard against re-entrance.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          	<span class="comment">// 调用initChannel()</span></span><br><span class="line">            initChannel((C) ctx.channel());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ChannelPipeline pipeline = ctx.pipeline();</span><br><span class="line">            <span class="keyword">if</span> (pipeline.context(<span class="keyword">this</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">              	<span class="comment">// 移除ChannelInitializer</span></span><br><span class="line">                pipeline.remove(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(C ch)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再来看一眼当时的<code>initChannel</code>是如何实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServerBootStrap.java</span></span><br><span class="line">p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        ChannelHandler handler = config.handler();</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pipeline.addLast(handler);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>此时的<code>pipeline.addLast(new ServerBootstrapAcceptor...)</code>中的<code>ServerBootstrapAcceptor</code>，是不是也会像<code>ChannleInitializer</code>一样被删除呢？</p>
<p>从直觉上来说，是不会的，因为如果删掉了谁来处理新建立的连接，那么它为什么没有被删掉呢？因为<code>ServerBootstrapAcceptor</code>并没有重写<code>handlerAdded()</code>这个方法，使用的父类默认实现，即啥都不干。它与<code>ChannelInitializer</code>同是继承自<code>ChannelInboundHandlerAdapter</code>，但是<code>ChannelInitializer</code>重写了<code>handlerAdded()</code>， 并在这个函数中，在初始化之后，将自身从pipeline上移除掉了。因为它只需要执行一次就即可。</p>
<p><img src="/images/pics/e03e90c9591e718f7652528fc4226a4b.png"></p>
<h6 id="safeSetSuccess-promise"><a href="#safeSetSuccess-promise" class="headerlink" title="safeSetSuccess(promise)"></a>safeSetSuccess(promise)</h6><p>使用了观察者模式，将执行之前注册到ChannelFuture上面的<code>ChannelFutureListener</code>，也就是会接着执行doBind0()。这部分代码逻辑比较明了，看关键的代码片段即可：</p>
<p><img src="/images/pics/34a2677da5b3b944079d989a07033566.png"></p>
<p>经典的观察者模式，套路满满。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多个Listener的时候，循环里面调用notifyListener0()方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyListeners0</span><span class="params">(DefaultFutureListeners listeners)</span> </span>&#123;</span><br><span class="line">    GenericFutureListener&lt;?&gt;[] a = listeners.listeners();</span><br><span class="line">    <span class="keyword">int</span> size = listeners.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">        notifyListener0(<span class="keyword">this</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单个Listener的时候执行</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notifyListener0</span><span class="params">(Future future, GenericFutureListener l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        l.operationComplete(future);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行此ChannelFutureListener，也就是进入doBind0()阶段，这个操作内容不多，只是将bind的具体操作放到了Runnable中，然后扔到eventLoop的taskQueue中，等待下次eventLoop执行该task。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractBootstrap.java</span></span><br><span class="line">regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Throwable cause = future.cause();</span><br><span class="line">        <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Registration was successful, so set the correct executor to use.</span></span><br><span class="line">            <span class="comment">// See https://github.com/netty/netty/issues/2586</span></span><br><span class="line">            promise.registered();</span><br><span class="line"></span><br><span class="line">            doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This method is invoked before channelRegistered() is triggered.  </span></span><br><span class="line">  	<span class="comment">// Give user handlers a chance to set up the pipeline </span></span><br><span class="line">  	<span class="comment">// in its channelRegistered() implementation.</span></span><br><span class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.setFailure(regFuture.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="fireChannelRegistered"><a href="#fireChannelRegistered" class="headerlink" title="fireChannelRegistered"></a>fireChannelRegistered</h6><p>关于消息的传递，可以放到后续的连接建立后的消息发送模块。这里先提出我的几个问题：</p>
<ul>
<li>事件如何在pipeline中传递？</li>
<li>什么是<code>executionMask</code>？这个实现看起来很有趣，通过<code>executionMask</code>与对应的事件编码相与，得出此Handler是否可以处理此消息。详细可后续进一步分析。</li>
</ul>
<p>至此register0的操作完成。</p>
<h5 id="2-doBind0"><a href="#2-doBind0" class="headerlink" title="2. doBind0"></a>2. doBind0</h5><p>框架代码的流程：从pipeline的tail出发，触发bind事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractBootstrap.java</span></span><br><span class="line">channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractChannel.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultChannelPipeline.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tail.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处的tail是<code>LoggingHandler</code>，也就是说会打印出bind日志：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractChannelHandlerContext.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  	<span class="comment">// 从tail,即DefaultChannelPipeline#TailContext开始，往前传递bind事件。</span></span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound(MASK_BIND);</span><br><span class="line">  	<span class="comment">// tail的前驱是LoggingHandler</span></span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeBind(localAddress, promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        safeExecute(executor, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                next.invokeBind(localAddress, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, promise, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeBind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          	<span class="comment">// 执行LogginHandler的bind方法。</span></span><br><span class="line">            ((ChannelOutboundHandler) handler()).bind(<span class="keyword">this</span>, localAddress, promise);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            notifyOutboundHandlerException(t, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bind(localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LogginHandler.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isEnabled(internalLevel)) &#123;</span><br><span class="line">        logger.log(internalLevel, format(ctx, <span class="string">&quot;BIND&quot;</span>, localAddress));</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 继续触发bind事件，必须传递，否则会出问题。</span></span><br><span class="line">    ctx.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里开始，又回到这个代码串的<code>bind()</code>方法处，直到执行invokeBind()时，才跳转到<code>LoggingHandler</code>的前驱，一个<code>DefaultChannelPipeline#HeadContext</code>，它才是bind操作的主要流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultChannelPipeline#HeadContext</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ChannelHandlerContext, SocketAddress, ChannelPromise)</span> </span>&#123;</span><br><span class="line">    unsafe.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractChannel.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">// 实际bind操作，调用jdk的api</span></span><br><span class="line">        doBind(localAddress);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        closeIfClosed();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">      	<span class="comment">// 只是将此Runnable添加到taskQueue中，等待下次触发执行</span></span><br><span class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// </span></span><br><span class="line">    safeSetSuccess(promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NioServerSocketChannel.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用栈：</p>
<p><img src="/images/pics/4105fe198207c2e49cb8f8486917301c.png"></p>
<p>至此bind操作完成。</p>
<h5 id="3-fireChannelActive"><a href="#3-fireChannelActive" class="headerlink" title="3. fireChannelActive"></a>3. fireChannelActive</h5><p>与<code>fireChannelRegistered</code>的调用类似，也是从pipeline的head开始触发，只是事件的名称换了，并且多了一个设置<code>OP_ACCEPT</code>的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultChannelPipeline.java</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadContext</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerContext</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ChannelOutboundHandler</span>, <span class="title">ChannelInboundHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传递给pipeline中head后面的handler</span></span><br><span class="line">        ctx.fireChannelActive();</span><br><span class="line">        <span class="comment">// 设置OP_ACCEPT事件</span></span><br><span class="line">        readIfIsAutoRead();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readIfIsAutoRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (channel.config().isAutoRead()) &#123;</span><br><span class="line">        channel.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractChannel.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Channel <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pipeline.read();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultChannelPipeline.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tail即TailContext</span></span><br><span class="line">    tail.read();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractChannelHandlerContext.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// next此时为HeadContext也就是head</span></span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound(MASK_READ);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123; <span class="comment">// 执行线程为eventloop</span></span><br><span class="line">        next.invokeRead();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((ChannelOutboundHandler) handler()).read(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            notifyHandlerException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultChannelPipeline.java$HeadContext</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    unsafe.beginRead();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractChannel.java$AbstractUnsafe</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">beginRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isActive()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doBeginRead();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pipeline.fireExceptionCaught(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        close(voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractNioMessageChannel.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inputShutdown) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.doBeginRead();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractNioChannel.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">    <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line">    <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readPending = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">    <span class="comment">// 将channel注册到selector上时，interestOps设置为0</span></span><br><span class="line">    <span class="comment">// readInterestOp为16，所以此时interestOps &amp; readInterestOp肯定会为0</span></span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置成监听OP_ACCEPT事件,为1 &lt;&lt; 4，即16</span></span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用栈为：</p>
<p><img src="/images/pics/f49809f866288e18da1fe7a64c397890.png"></p>
<p>通过eventLoop来执行task的方式，其实是通过一个taskQueue来接收这些Runnable，然后eventLoop再通过统一调度，获取taskQueue里面的task，然后依次执行它们。所以这里还有最后一个问题：<strong>eventLoop是怎么启动起来的以及如何进行调度</strong>？</p>
<h2 id="EventLoop的启动与调度"><a href="#EventLoop的启动与调度" class="headerlink" title="EventLoop的启动与调度"></a>EventLoop的启动与调度</h2><p>时机：第一次在main线程中，调用EventLoop执行task的时候，会进行初始化。最早出现在<code>initAndRegister()</code>这个方法中，这个方法进行register()的时候，会将register0放到一个Runnable中，扔给eventLoop去执行，即：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractChannel.java</span></span><br><span class="line">eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// SingleThreadEventExecutor.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">    addTask(task);</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">        startThread();</span><br><span class="line">        <span class="keyword">if</span> (isShutdown()) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> reject = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (removeTask(task)) &#123;</span><br><span class="line">                    reject = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedOperationException e) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (reject) &#123;</span><br><span class="line">                reject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; immediate) &#123;</span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state == ST_NOT_STARTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                doStartThread();</span><br><span class="line">                success = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                    STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, ST_STARTED, ST_NOT_STARTED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> thread == <span class="keyword">null</span>;</span><br><span class="line">    executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          	<span class="comment">// 此时的线程为EventLoop</span></span><br><span class="line">            thread = Thread.currentThread();</span><br><span class="line">            <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                thread.interrupt();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">            updateLastExecutionTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              	<span class="comment">// 对EchoServer这个例子来说this为NioEventLoop</span></span><br><span class="line">                SingleThreadEventExecutor.<span class="keyword">this</span>.run();</span><br><span class="line">                success = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码是对整个事件处理的核心：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NioEventLoop.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> strategy;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());</span><br><span class="line">                <span class="keyword">switch</span> (strategy) &#123;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.BUSY_WAIT:</span><br><span class="line">                    <span class="comment">// fall-through to SELECT since the busy-wait is not supported with NIO</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                    <span class="keyword">long</span> curDeadlineNanos = nextScheduledTaskDeadlineNanos();</span><br><span class="line">                    <span class="keyword">if</span> (curDeadlineNanos == -<span class="number">1L</span>) &#123;</span><br><span class="line">                        curDeadlineNanos = NONE; <span class="comment">// nothing on the calendar</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    nextWakeupNanos.set(curDeadlineNanos);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!hasTasks()) &#123;</span><br><span class="line">                            strategy = select(curDeadlineNanos);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// This update is just to help block unnecessary selector wakeups</span></span><br><span class="line">                        <span class="comment">// so use of lazySet is ok (no race condition)</span></span><br><span class="line">                        nextWakeupNanos.lazySet(AWAKE);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// fall through</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// If we receive an IOException here its because the Selector is messed up. Let&#x27;s rebuild</span></span><br><span class="line">                <span class="comment">// the selector and retry. https://github.com/netty/netty/issues/8566</span></span><br><span class="line">                rebuildSelector0();</span><br><span class="line">                selectCnt = <span class="number">0</span>;</span><br><span class="line">                handleLoopException(e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            selectCnt++;</span><br><span class="line">            cancelledKeys = <span class="number">0</span>;</span><br><span class="line">            needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">            <span class="keyword">boolean</span> ranTasks;</span><br><span class="line">            <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        processSelectedKeys();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                    ranTasks = runAllTasks();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                    ranTasks = runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ranTasks = runAllTasks(<span class="number">0</span>); <span class="comment">// This will run the minimum number of tasks</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ranTasks || strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS &amp;&amp; logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row for Selector &#123;&#125;.&quot;</span>,</span><br><span class="line">                            selectCnt - <span class="number">1</span>, selector);</span><br><span class="line">                &#125;</span><br><span class="line">                selectCnt = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (unexpectedSelectorWakeup(selectCnt)) &#123; <span class="comment">// Unexpected wakeup (unusual case)</span></span><br><span class="line">                selectCnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            <span class="comment">// Harmless exception - log anyway</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(CancelledKeyException.class.getSimpleName() + <span class="string">&quot; raised by a Selector &#123;&#125; - JDK bug?&quot;</span>,</span><br><span class="line">                        selector, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Always handle shutdown even if the loop processing threw an exception.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">                closeAll();</span><br><span class="line">                <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-02-18T14:03:28.000Z" title="2/18/2020, 10:03:28 PM">2020-02-18</time>发表</span><span class="level-item"><time dateTime="2021-02-09T03:03:20.259Z" title="2/9/2021, 11:03:20 AM">2021-02-09</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span><span class="level-item">21 分钟读完 (大约3084个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/18/32c129172610.html">4 | Netty：JavaNIO概览</a></h1><div class="content"><blockquote>
<p>在正式开始Netty相关的学习之前，我决定还是要先回顾一下Java NIO，至少要对Java NIO相关的概念有一个了解，如Channel、ByteBuffer、Selector等。要自己动手写一写相关的demo实例、并且要尽可能地去了解其后面是如何实现的，也就是稍微看看相关jdk的源代码。</p>
</blockquote>
<p>Java NIO 由以下几个核心部分组成：Buffer, Channel, Selector。传统的IO操作面向数据流，面向流 的 I/O 系统一次一个字节地处理数据，意味着每次从流中读一个或多个字节，直至完成，数据没有被缓存在任何地方；NIO操作面向缓冲区（ 面向块），数据从Channel读取到Buffer缓冲区，随后在Buffer中处理数据。</p>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>可以理解成煤矿里面挖煤的小车，把煤从井底运地面上面。它的属性与子类如下：</p>
<p><img src="/images/pics/358b9e9f19bfd074418733e04565f1b0.png"></p>
<p>Buffer是一个抽象类，继承自Object，拥有多个子类。此类在JDK源码中的注释如下：</p>
<blockquote>
<p>A container for data of a specific primitive type. </p>
<p>A buffer is a <strong>linear, finite sequence of elements of a specific primitive type</strong>. Aside from its content, the essential properties of a buffer are its <code>capacity</code>, <code>limit</code>, and <code>position</code>:</p>
<ul>
<li><p>A buffer’s <code>capacity</code> is <strong>the number of elements it contains</strong>. The capacity of a buffer is never negative and never changes.</p>
</li>
<li><p>A buffer’s <code>limit</code> is <strong>the index of the first element that should not be read or written</strong>. A buffer’s limit is never negative and is never greater than its capacity.</p>
<p><strong>写模式下</strong>，limit表示最多能往Buffer里写多少数据，等于capacity值；<strong>读模式下</strong>，limit表示最多可以读取多少数据，小于等于 capacity 值。</p>
</li>
<li><p>A buffer’s <code>position</code> is <strong>the index of the next element to be read or written</strong>. A buffer’s position is never negative and is never greater than its limit.</p>
</li>
</ul>
<p>There is one subclass of this class for each non-boolean primitive type.</p>
<h2 id="Transferring-data"><a href="#Transferring-data" class="headerlink" title="Transferring data"></a>Transferring data</h2><p>Each subclass of this class defines <strong>two categories of get and put operations</strong>:</p>
<ul>
<li><p>Relative operations read or write one or more elements starting at the current position and then increment the position by the number of elements transferred. If the requested transfer exceeds the limit then a relative get operation throws a <code>BufferUnderflowException</code> and a relative put operation throws a <code>BufferOverflowException</code>; in either case, no data is transferred.</p>
</li>
<li><p>Absolute operations take an explicit element index and do not affect the position. Absolute get and put operations throw an <code>IndexOutOfBoundsException</code> if the index argument exceeds the limit.</p>
</li>
</ul>
<p>Data may also, of course, be transferred in to or out of a buffer by the I/O operations of an appropriate channel, which are always relative to the current position.</p>
<h2 id="Marking-and-resetting"><a href="#Marking-and-resetting" class="headerlink" title="Marking and resetting"></a>Marking and resetting</h2><p>A buffer’s <code>mark</code> is <strong>the index to which its position will be reset when the reset method is invoked</strong>. The mark is not always defined, but when it is defined it is never negative and is never greater than the position. If the mark is defined then it is discarded when the position or the limit is adjusted to a value smaller than the mark. If the mark is not defined then invoking the reset method causes an <code>InvalidMarkException</code> to be thrown.</p>
<h2 id="Invariants"><a href="#Invariants" class="headerlink" title="Invariants"></a>Invariants</h2><p>The following invariant holds for the mark, position, limit, and capacity values:</p>
<p><strong><code>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</code></strong></p>
<p>A newly-created buffer always has a position of zero and a mark that is undefined. The initial limit may be zero, or it may be some other value that depends upon the type of the buffer and the manner in which it is constructed. Each element of a newly-allocated buffer is initialized to zero.</p>
<h2 id="Clearing-flipping-and-rewinding"><a href="#Clearing-flipping-and-rewinding" class="headerlink" title="Clearing, flipping, and rewinding"></a>Clearing, flipping, and rewinding</h2><p>In addition to methods for accessing the <code>position</code>, <code>limit</code>, and <code>capacity</code> values and for marking and resetting, this class also defines the following operations upon buffers:</p>
<ul>
<li><p><code>clear()</code> <strong>makes a buffer ready for a new sequence of channel-read or relative put operations</strong>: It sets the limit to the capacity and the position to zero.</p>
</li>
<li><p><code>flip()</code> <strong>makes a buffer ready for a new sequence of channel-write or relative get operations</strong>: It sets the limit to the current position and then sets the position to zero. </p>
</li>
<li><p><code>rewind()</code> <strong>makes a buffer ready for re-reading the data that it already contains</strong>: It leaves the limit unchanged and sets the position to zero.</p>
</li>
</ul>
<h2 id="Read-only-buffers"><a href="#Read-only-buffers" class="headerlink" title="Read-only buffers"></a>Read-only buffers</h2><p>Every buffer is readable, but not every buffer is writable. The mutation methods of each buffer class are specified as optional operations that will throw a <code>ReadOnlyBufferException</code> when invoked upon a read-only buffer. A read-only buffer does not allow its content to be changed, but its mark, position, and limit values are mutable. Whether or not a buffer is read-only may be determined by invoking its isReadOnly method.</p>
<h2 id="Thread-safety"><a href="#Thread-safety" class="headerlink" title="Thread safety"></a>Thread safety</h2><p>Buffers are not safe for use by multiple concurrent threads. If a buffer is to be used by more than one thread then access to the buffer should be controlled by appropriate synchronization.</p>
<h2 id="Invocation-chaining"><a href="#Invocation-chaining" class="headerlink" title="Invocation chaining"></a>Invocation chaining</h2><p>Methods in this class that do not otherwise have a value to return are specified to return the buffer upon which they are invoked. This allows method invocations to be chained; for example, the sequence of statements</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b.flip();</span><br><span class="line">b.position(<span class="number">23</span>);</span><br><span class="line">b.limit(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>can be replaced by the single, more compact statement<br><code>b.flip().position(23).limit(42);</code></p>
</blockquote>
<p>clear()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除Buffer中的信息，只将参数恢复成默认</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>flip()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将limit记录成当前的位置，指针指向头部，为读取做准备</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rewind()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指针指向头部，可以用于再次读取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何使用Java-NIO读取文件内容"><a href="#如何使用Java-NIO读取文件内容" class="headerlink" title="如何使用Java NIO读取文件内容"></a>如何使用Java NIO读取文件内容</h2><p>遇到坑了，但是感觉可以透过这个问题更加深入理解Java NIO的这些概念。出现问题的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fileChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;/Users/yangyu/Documents/data.json&quot;</span>);</span><br><span class="line">    FileChannel fileChannel = fis.getChannel();</span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">while</span> ((fileChannel.read(byteBuffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) byteBuffer.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码读取不到数据，一直在做循环，但是不输出数据。为什么？因为<code>hasRemaining()</code>是以<code>position</code>和<code>limit</code>作对比，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasRemaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> position &lt; limit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当从<code>fileChannel</code>中读取数据到<code>byteBuffer</code>中之后，<code>limit</code>与<code>capacity</code>相等（初始化既如此），此时的<code>position</code>也与<code>capacity</code>相同，导致<code>hasRemaining()</code>为<code>false</code>，无法向控制台输出。</p>
<p><img src="/images/pics/2287caff23cf31b7b9d1875ebd3409ab.png"></p>
<p>所以需要将position设置成从0开始，让读取从0开始，直到读到之前的容量，所以使用<code>flip()</code>来完成这个目的，即：</p>
<p><img src="/images/pics/29313e71a77b5ac264e866b91dcb3dd4.png"></p>
<p>此时却发现控制台无限打印东西，为了弄明白这是为什么，我把<code>byteBuffer</code>的大小调成了8，跑起来之后的输出如下：</p>
<p><img src="/images/pics/4bb436717c4bfece138cf4ae2fa6944c.png"></p>
<p>这是为什么呢？这个问题应该与<code>byteBuffer</code>里面的那几个参数有关系：</p>
<p><img src="/images/pics/aa55dc39c41d692cdd27c30a756b40ab.png"></p>
<p>猜测应该是与<code>fileChannel.read(byteBuffer)</code>中的具体实现有关。粗略看了看<code>fileChannel.read(byteBuffer)</code>的实现，大致流程如下：</p>
<ol>
<li><p>计算<code>byteBuffer</code>的剩余量，即<code>limit - position</code>。对于上面的情况，剩余量为0。</p>
</li>
<li><p>找出缓存buffer，此时缓存buffer为上次read得到的，第一次为空会直接分配；第二次<code>read</code>的时候，其3大属性全部为8，也即上次读取的结果。</p>
</li>
<li><p>将缓存的buffer进行<code>rewind()</code>、<code>flip(剩余量)</code>，得到一个[pos=0, limit=0, capacity=8]的buffer。</p>
</li>
<li><p>进行读取的时候回根据缓存buffer的pos、limit来确定能读取的数量，也即：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其中var1为缓存buffer</span></span><br><span class="line"><span class="keyword">int</span> var5 = var1.position();</span><br><span class="line"><span class="keyword">int</span> var6 = var1.limit();</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> var5 &lt;= var6;</span><br><span class="line"><span class="comment">// var6 - var5 = limit - position = 0</span></span><br><span class="line"><span class="keyword">int</span> var7 = var5 &lt;= var6 ? var6 - var5 : <span class="number">0</span>;</span><br><span class="line"><span class="comment">// var7 = 0</span></span><br><span class="line"><span class="keyword">if</span> (var7 == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 0 即读取的字节数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果能读到数据，会将缓存buffer里面的的内容再转移到<code>byteBuffer</code>（也就是我们<code>read()</code>里面传的<code>ByteBuffer</code>）中：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var5即缓存buffer，读取内容到var5中</span></span><br><span class="line"><span class="keyword">int</span> var6 = readIntoNativeBuffer(var0, var5, var2, var4);</span><br><span class="line"><span class="comment">// 准备用来读取</span></span><br><span class="line">var5.flip();</span><br><span class="line"><span class="comment">// var1是我们传入的byteBuffer，如果读取到的字节数大于0，</span></span><br><span class="line"><span class="keyword">if</span> (var6 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 将var5中的内容拷贝到var1中</span></span><br><span class="line">  var1.put(var5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>直到发现<code>flip()</code>的注释里面有这样一段注释：</p>
<blockquote>
<p>Compacts this buffer  (optional operation).<br>The bytes between the buffer’s current position and its limit, if any, are copied to the beginning of the buffer. That is, the byte at index <code>p = position()</code> is copied to index zero, the byte at index <code>p + 1</code> is copied to index one, and so forth until the byte at index <code>limit() - 1</code> is copied to index <code>n = limit() - 1 - p</code>. The buffer’s position is then set to <code>n+1</code> and its limit is set to its <code>capacity</code>. The <code>mark</code>, if defined, is discarded.</p>
<p>The buffer’s <code>position</code> is set to the number of bytes copied, rather than to zero, so that an invocation of this method can be followed immediately by an invocation of another relative put method.</p>
<p>Invoke this method after writing data from a buffer in case the write was incomplete. The following loop, for example, copies bytes from one channel to another via the buffer buf:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">buf.clear();          <span class="comment">// Prepare buffer for use</span></span><br><span class="line"><span class="keyword">while</span> (in.read(buf) &gt;= <span class="number">0</span> || buf.position != <span class="number">0</span>) &#123;</span><br><span class="line">  buf.flip();</span><br><span class="line">  out.write(buf);</span><br><span class="line">  buf.compact();    <span class="comment">// In case of partial write</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>加上这段代码<code>buf.compact()</code>便可以正常读取文件内容。到这里就有点心累了，为什么写个读取都这么多坑。感觉有问题的时候往这三个参数上面想就行了。</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>煤矿厂里面运煤的通道，需要看的子类总共有4个，分别为：</p>
<ul>
<li><code>FileChannel</code>：文件通道，用于文件的读和写。不支持非阻塞</li>
<li><code>DatagramChannel</code>：用于 UDP 连接的接收和发送</li>
<li><code>SocketChannel</code>：把它理解为 TCP 连接通道，简单理解就是 TCP 客户端</li>
<li><code>ServerSocketChannel</code>：TCP 对应的服务端，用于监听某个端口进来的请求</li>
</ul>
<p><img src="/images/pics/05a1b02bcd807d248d5d0bd9cb9425f4.png"></p>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>只有自己写过的代码才会有更深刻的印象，哪怕是从别的地方抄来的，自己慢慢debug一下，找出自己对代码的疑问，然后再去搞清楚这些问题，我觉得这样让我对它的了解会更深。这两段代码基本和网上的教程类似，大部分是抄的，但是自己有一定的加工，也遇到了1个问题，外加一个疑问。</p>
<h3 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h3><p>客户端的代码很简单：①读标准输入。②发送给Server端。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Client端的代码很像八股文，这样弄就行了。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SocketChannel sc = SocketChannel.open();</span><br><span class="line">    sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    sc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8086</span>));</span><br><span class="line"></span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">if</span> (sc.finishConnect()) &#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">          	<span class="comment">// 读标准输入</span></span><br><span class="line">            String info = scanner.nextLine();</span><br><span class="line">            buffer.clear();</span><br><span class="line">            buffer.put(info.getBytes());</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                System.out.println(buffer);</span><br><span class="line">              	<span class="comment">// 发送给Server端</span></span><br><span class="line">                sc.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h3><p>主要参考了<a target="_blank" rel="noopener" href="https://blog.csdn.net/u011381576/article/details/79876754">一篇CSDN上的博客</a>和<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6bdee8cfee90">一篇简书上的博客</a>，简书上面的这边对我的帮助很大，十分感谢。我的问题主要有两点，第一个是少了<code>it.remove();</code>，第二个是关于如何触发<code>SelectionKey.OP_WRITE</code>事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 八股文的感觉。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">    ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    ssc.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8086</span>));</span><br><span class="line"></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        selector.select();</span><br><span class="line">        Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            SelectionKey key = it.next();</span><br><span class="line">            <span class="comment">// 一定要remove掉，不然上次的事件会累积。</span></span><br><span class="line">            <span class="comment">// 也就是对同一事件会处理两次，这样可能会导致报错。</span></span><br><span class="line">            it.remove();</span><br><span class="line">            <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ACCEPT&quot;</span>);</span><br><span class="line">                ServerSocketChannel ssChannel = (ServerSocketChannel)key.channel();</span><br><span class="line">                SocketChannel sc = ssChannel.accept();</span><br><span class="line">                sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                sc.register(key.selector(), SelectionKey.OP_READ, ByteBuffer.allocateDirect(BUF_SIZE));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;READ：&quot;</span>);</span><br><span class="line">                SocketChannel sc = (SocketChannel)key.channel();</span><br><span class="line">                ByteBuffer buf = (ByteBuffer)key.attachment();</span><br><span class="line">                <span class="keyword">long</span> bytesRead = sc.read(buf);</span><br><span class="line">                <span class="keyword">while</span>(bytesRead&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    buf.flip();</span><br><span class="line">                    <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">                        System.out.print((<span class="keyword">char</span>)buf.get());</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println();</span><br><span class="line">                    buf.clear();</span><br><span class="line">                    bytesRead = sc.read(buf);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(bytesRead == -<span class="number">1</span>)&#123;</span><br><span class="line">                    sc.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                <span class="comment">// OP_WRITE事件如何触发？</span></span><br><span class="line">                System.out.print(<span class="string">&quot;WRITE：&quot;</span>);</span><br><span class="line">                ByteBuffer buf = (ByteBuffer) key.attachment();</span><br><span class="line">                buf.flip();</span><br><span class="line">                SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">                    sc.write(buf);</span><br><span class="line">                &#125;</span><br><span class="line">                buf.compact();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;CONNECT&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;UNKNOWN&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果缺少<code>it.remove()</code>方法的调用，那么会导致事件会堆积在Selector的<code>Set&lt;SelectionKey&gt; publicSelectedKeys</code>中，引发对同一事件会处理两次，这样可能会导致报错。</li>
<li>如何触发<code>SelectionKey.OP_WRITE</code>？因为我看到大部分关于selector的博客，都没有写如何触发该事件，并且也未对读事件做出说明。</li>
</ol>
<p>首先肯定要在调用<code>ssChannel.accept()</code>之后，将得到的<code>SocketChannel</code>多注册一个<code>OP_WRITE</code>事件。即修改成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel sc = ssChannel.accept();</span><br><span class="line">sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">sc.register(key.selector(), SelectionKey.OP_READ | SelectionKey.OP_WRITE,ByteBuffer.allocateDirect(BUF_SIZE));</span><br></pre></td></tr></table></figure>

<p>然后会发现程序卡死，屏幕一直输出<code>Write</code>。为什么会有这么多<code>OP_WRITE</code>事件？因为Java NIO的事件触发是<strong>水平触发</strong>，即<strong>只要满足条件，就触发一个事件</strong>，所以<strong>只要内核缓冲区还不满，就一直发出<code>OP_WRITE</code>事件</strong>。</p>
<p>与水平触发对应的还有一个叫做<strong>边缘触发</strong>，即<strong>每当状态变化时，触发一个事件</strong>。对之前的Netty的事件是边缘触发又有了一个认识。</p>
<p><img src="/images/pics/67d7ed2cda649eeea74d40b67e6483b7.png"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-02-11T03:36:30.000Z" title="2/11/2020, 11:36:30 AM">2020-02-11</time>发表</span><span class="level-item"><time dateTime="2021-02-09T03:03:37.480Z" title="2/9/2021, 11:03:37 AM">2021-02-09</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span><span class="level-item">2 分钟读完 (大约287个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/11/96e6a8296171.html">3 | Netty：源代码导入IDEA</a></h1><div class="content"><blockquote>
<p>Netty源代码导入IDEA时需要注意的地方</p>
</blockquote>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>64位</p>
<h2 id="版本问题"><a href="#版本问题" class="headerlink" title="版本问题"></a>版本问题</h2><ul>
<li><p>官网上面说可以用64-bit OpenJDK 8 or above 。没有尝试OpenJDK，Oracle的JDK要1.8版本的。源码里面用到了<code>Unsafe</code>这个类，在jdk1.8之后的版本中被移除掉了。</p>
</li>
<li><p>IDEA的位数保持与操作系统位数相同</p>
</li>
</ul>
<h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><ol start="0">
<li>最好先设置好maven的镜像，导入时需要拉取很多jar包。</li>
<li>打开IDEA，选择<code>Import Project</code>，选择好netty源码目录后再选择maven。</li>
<li>等待Import完成，找到<code>EchoServer</code>，跑main方法，这时会报错，按照如下方式操作即可。</li>
</ol>
<p>如果用的不是jdk1.8以上的jdk，会报Unsafe找不到，这种情况只需要在<code>Project Structure</code>中将<code>Project SDK</code>设置成jdk1.8即可。</p>
<p>如果是<code>io.netty.util.collection.LongObjectMap</code>找不到之类的错误，可以在<code>netty-common</code>模块中执行<code>mvn clean compile</code>，可以按下图方式进行操作该指令。</p>
<p><img src="/images/pics/1426e3800ca1ea4e9709a88ab3f73af8.png"></p>
<ol start="4">
<li>操作完成</li>
</ol>
<p>参考：<br><a target="_blank" rel="noopener" href="https://netty.io/wiki/setting-up-development-environment.html">https://netty.io/wiki/setting-up-development-environment.html</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-02-02T15:35:37.000Z" title="2/2/2020, 11:35:37 PM">2020-02-02</time>发表</span><span class="level-item"><time dateTime="2021-02-09T03:04:00.483Z" title="2/9/2021, 11:04:00 AM">2021-02-09</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span><span class="level-item">14 分钟读完 (大约2031个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/02/8dae1f5a56e2.html">2 | Netty：Reactor与Netty之间的关系</a></h1><div class="content"><blockquote>
<p>今天是2020年2月2号，感觉是一个比较特殊的日子，今天就来一篇记录型的博客吧，哈哈</p>
</blockquote>
<blockquote>
<p>起初很好奇，到底什么叫Reactor模式，这个名词感觉特别高大上，然后看描述，虽然能看懂描述，但是却不是特别明白到底是什么意思。这个时候主要是没有形成一种直观的印象，直观的印象就是比如说苹果，再给你看个实物，你就能把苹果与关联起来。在学习netty的时候，也遇到了Reactor模式，于是有了机会来形成一种比较直观的印象。</p>
</blockquote>
<h2 id="什么是Reactor模式？"><a href="#什么是Reactor模式？" class="headerlink" title="什么是Reactor模式？"></a>什么是Reactor模式？</h2><p>定义看起来很抽象，但是其实很好理解。<strong>它是一种开发模式，模式的核心流程：注册感兴趣的事件 -&gt; 扫描是否有感兴趣的事件发生 -&gt; 事件发生后做出相应的处理。</strong>仅此而已。使用BIO开发的时候，每有一个新的请求过来了，都会新开一个线程，然后在新的线程里面进行业务处理，这种处理方式就是Thread-Per-Connection；<br><img src="/images/pics/d4276c6290bbde90f202dc3ebecef450.png"><br>所以对应起来，使用NIO开发的时候，也有一个模式去处理相应的请求与业务逻辑，叫做Reactor模式。至于具体怎么做，也就是前面提到的Reactor模式的核心流程。</p>
<h2 id="Reactor模式的3种版本"><a href="#Reactor模式的3种版本" class="headerlink" title="Reactor模式的3种版本"></a>Reactor模式的3种版本</h2><p>开始这个之前我有一个疑问：<strong>Thread-Per-Connection与Reactor单线程有什么关系？</strong></p>
<h3 id="Thread-Per-Connection模式"><a href="#Thread-Per-Connection模式" class="headerlink" title="Thread-Per-Connection模式"></a>Thread-Per-Connection模式</h3><p>示意图：<br><img src="/images/pics/5c704784eab7978eda52e221dd0234d9.png"></p>
<p>伪代码：<br><img src="/images/pics/4112bf4861c209951645583dd9919dac.png"></p>
<h3 id="Reactor单线程模式"><a href="#Reactor单线程模式" class="headerlink" title="Reactor单线程模式"></a>Reactor单线程模式</h3><p><img src="/images/pics/f7fcfabb89dda2939ebab2a29d2f67dd.png"></p>
<p><strong>从这张图里面看不懂其执行流是什么样的。待后续理解了再补上解读。</strong></p>
<h3 id="Reactor多线程模式"><a href="#Reactor多线程模式" class="headerlink" title="Reactor多线程模式"></a>Reactor多线程模式</h3><p><img src="/images/pics/70c2ac21a6f0fd0d9887b9f560b39c1b.png"></p>
<h3 id="主从Reactor多线程模式"><a href="#主从Reactor多线程模式" class="headerlink" title="主从Reactor多线程模式"></a>主从Reactor多线程模式</h3><p>对服务器开发来说，很重要的事情是<strong>接收连接</strong>，accept事件会被单独注册到另外一个reactor中。</p>
<p><img src="/images/pics/e7f8e19946df95af9368b39c70770cfb.png"></p>
<h2 id="在Netty中如何实现Reactor三种模式"><a href="#在Netty中如何实现Reactor三种模式" class="headerlink" title="在Netty中如何实现Reactor三种模式"></a>在Netty中如何实现Reactor三种模式</h2><p><img src="/images/pics/0c25fd879520d4fc4512b84edb147443.png"></p>
<p>其中单线程和非主从reactor多线程模式的差别只在于new的时候传入的线程数量，不传的话，会默认以CPU的核数为依据来确定最终的线程数。</p>
<h2 id="Netty-如何支持主从-Reactor-模式"><a href="#Netty-如何支持主从-Reactor-模式" class="headerlink" title="Netty 如何支持主从 Reactor 模式"></a>Netty 如何支持主从 Reactor 模式</h2><p>以netty项目源代码（分支4.1）中netty-example模块的<code>EchoServer</code>为例。</p>
<h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><p>它是一个主从reactor多线程模式，其中<code>bossGroup</code>负责accept事件，<code>workerGroup</code>负责逻辑处理。</p>
<p><img src="/images/pics/9250e2f3ddb09e12ef10c7669f61eab4.png"></p>
<p>在①中，分别将两个<code>EventLoopGroup</code>传入到<code>ServerBootstrap</code>中，并将这两个<code>EventLoopGroup</code>保存起来。</p>
<p><img src="/images/pics/e0a01abdda81ff36a236d57eb2a8d3aa.png"></p>
<p>步骤②执行的保存逻辑如下：</p>
<p><img src="/images/pics/42ed84c2f4e3c4c3949fab99e9c8fbb7.png"></p>
<p>步骤③即已保存完毕。保存起来之后，什么时候使用呢？</p>
<h3 id="将channel注册到parentGroup"><a href="#将channel注册到parentGroup" class="headerlink" title="将channel注册到parentGroup"></a>将channel注册到<code>parentGroup</code></h3><p>先看<code>parentGroup</code>的使用过程，找到使用了<code>group</code>这个变量的地方<code>Ctrl + B</code>：</p>
<p><img src="/images/pics/5ea46457187c2fc441a3c79d4091d69d.png"></p>
<p>进去之后，是一个类似于普通getter方法</p>
<p><img src="/images/pics/e98d7e5cfe4b2ba4552cad07bc33956c.png"></p>
<p>只有一个地方调用，名称也叫<code>group()</code>，所以还可以继续往上看调用者</p>
<p><img src="/images/pics/90ffc0b1739c6604b65c170cc8367d46.png"></p>
<p>然后使用<code>Ctrl + Alt + H</code>查看该<code>group()</code>方法的调用者：</p>
<p><img src="/images/pics/3abc336c0b16933e5c432513286ef4d3.png"></p>
<p>在<code>initAndRegister()</code>中可以找到将<code>channel</code>（即<code>ServerSocketChannel</code>）注册到该<code>EventLoopGroup</code>的代码，如下：</p>
<p><img src="/images/pics/8a2758d95115c4fd0e50da3b70bb880f.png"></p>
<p>绑定完毕。</p>
<h3 id="将channel注册到childGroup"><a href="#将channel注册到childGroup" class="headerlink" title="将channel注册到childGroup"></a>将<code>channel</code>注册到<code>childGroup</code></h3><p>找到使用了<code>childGroup</code>这个变量的地方<code>Ctrl + B</code>：</p>
<p><img src="/images/pics/8301a2a1dadc3e37dc08739221b7805f.png"></p>
<p>只有个地方使用到了该<code>childGroup</code>，并改名成了<code>currentChildGroup</code>。</p>
<p><img src="/images/pics/8544480bd39504a3d2519ae6ed7f7866.png"></p>
<p>①改名，②将<code>childGroup</code>作为一个变量，传入<code>ServerBootstrapAcceptor</code>中。<code>ServerBootstrapAcceptor</code>继承自<code>ChannelInboundHandlerAdapter</code>，其覆盖了父类的<code>channelRead()</code>方法，其中将新进来的<code>channel</code>注册到<code>childGroup</code>中。</p>
<p><img src="/images/pics/40b093594ef5accf127dea3cdd41adb5.png"></p>
<p>也就是说，新进来的连接，即<code>SocketChannel</code>，都会被注册到<code>childGroup</code>中。</p>
<h3 id="新连接建立进行哪些初始化"><a href="#新连接建立进行哪些初始化" class="headerlink" title="新连接建立进行哪些初始化"></a>新连接建立进行哪些初始化</h3><p>回到上面的<code>init()</code>方法中提出的，它是何时被调用的这个问题中。</p>
<p>它是<code>AbstractBootstrap</code>抽象类中的一个抽象方法，有两个类继承自<code>AbstractBootstrap</code>，分别是<code>Bootstrap</code>和<code>ServerBootstrap</code>。调用<code>init()</code>方法的地方只有一个，即<code>initAndRegister()</code>中。</p>
<p><img src="/images/pics/2d04dfe36a653774a3a88d3e86df1357.png"></p>
<p>其中传入<code>init()</code>的<code>channel</code>为<code>ServerSocketChannel</code>，其大致过程：</p>
<p>当服务端即<code>EchoServer</code>启动的时候，会为<code>ServerSocketChannel</code>的pipeline添加一个<code>ServerBootstrapAcceptor</code>，所以每当有来自客户端的请求时，都会首先经过<code>ServerBootstrapAcceptor</code>，让它先处理，而它的处理内容就是将<code>SocketChannel</code>注册到<code>childGroup</code>中。</p>
<h2 id="为什么说-Netty-的-main-reactor-大多并不能用到一个线程组，只能线程组里面的一个？"><a href="#为什么说-Netty-的-main-reactor-大多并不能用到一个线程组，只能线程组里面的一个？" class="headerlink" title="为什么说 Netty 的 main reactor 大多并不能用到一个线程组，只能线程组里面的一个？"></a>为什么说 Netty 的 main reactor 大多并不能用到一个线程组，只能线程组里面的一个？</h2><p>因为服务端只会启动一次，只有在启动过程中去绑定端口号时才会将<code>ServerSocketChannel</code>绑定到<code>main reactor</code>上。所以这时候要从<code>initAndRegister</code>的调用者逐级往上查看，如下；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(InetAddress inetHost, <span class="keyword">int</span> inetPort)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bind(<span class="keyword">new</span> InetSocketAddress(inetHost, inetPort));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    validate();</span><br><span class="line">    <span class="keyword">return</span> doBind(ObjectUtil.checkNotNull(localAddress, <span class="string">&quot;localAddress&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        <span class="comment">// 设置新接入连接的SocketChannel注册到sub reactor</span></span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册ServerSocketChannel到main reactor</span></span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以一个<code>ServerSocketChannel</code>只会注册到一个group中。但还是个疑问，是与EventLoopGroup相关的，留待后续再来回答。这个问题的意思是说，<strong>只能用线程组里面的一个线程</strong>，为什么？为什么不能多个线程？下面这个问题可以回答这个疑问！</p>
<h2 id="Netty-给-Channel-分配-NIO-event-loop-的规则是什么"><a href="#Netty-给-Channel-分配-NIO-event-loop-的规则是什么" class="headerlink" title="Netty 给 Channel 分配 NIO event loop 的规则是什么"></a>Netty 给 Channel 分配 NIO event loop 的规则是什么</h2><p>从<code>initAndRegister()</code>中的<code>config().group().register(channel)</code>代码出发，也就是<code>ServerSocketChannel</code>注册到main reactor中的那段代码（参见上面）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从register方法进入</span></span><br><span class="line">ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入EventLoopGroup.java，它是一个接口。</span></span><br><span class="line"><span class="comment">// NIO选MultithreadEventLoopGroup的实现</span></span><br><span class="line"><span class="function">ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> next().register(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventLoop <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (EventLoop) <span class="keyword">super</span>.next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入父类的next()实现中</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> chooser.next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入chooser的next()方法，发现这个chooser是一个接口类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventExecutorChooserFactory.EventExecutorChooser chooser;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventExecutorChooserFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">EventExecutorChooser <span class="title">newChooser</span><span class="params">(EventExecutor[] executors)</span></span>;</span><br><span class="line">    <span class="meta">@UnstableApi</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventExecutorChooser</span> </span>&#123;</span><br><span class="line">        <span class="function">EventExecutor <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// chooser的初始化是根据传入的线程数决定的</span></span><br><span class="line"><span class="comment">// 在MultithreadEventExecutorGroup的构造函数中</span></span><br><span class="line">children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line"><span class="comment">// 需要多少个线程，就有多少个EventExecutor，它初步与Thread等价</span></span><br><span class="line">chooser = chooserFactory.newChooser(children);</span><br></pre></td></tr></table></figure>

<p>所以<code>chooser.next()</code>返回的是一个等价于Thread的对象，也就是说这个<code>ServerSocketChannel</code>只会在这个Thread中进行接收。其中的chooser就是根据线程数的个数，来选取一个线程分配给register进来的<code>ServerSocketChannel</code>。具体分配策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next()是一个抽象方法，它的具体实现有两种</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventExecutorChooser <span class="title">newChooser</span><span class="params">(EventExecutor[] executors)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isPowerOfTwo(executors.length)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PowerOfTwoEventExecutorChooser(executors);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GenericEventExecutorChooser(executors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为2的幂的简便方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (val &amp; -val) == val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerOfTwoEventExecutorChooser</span> <span class="keyword">implements</span> <span class="title">EventExecutorChooser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger idx = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventExecutor[] executors;</span><br><span class="line"></span><br><span class="line">    PowerOfTwoEventExecutorChooser(EventExecutor[] executors) &#123;</span><br><span class="line">        <span class="keyword">this</span>.executors = executors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executors[idx.getAndIncrement() &amp; executors.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericEventExecutorChooser</span> <span class="keyword">implements</span> <span class="title">EventExecutorChooser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger idx = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventExecutor[] executors;</span><br><span class="line"></span><br><span class="line">    GenericEventExecutorChooser(EventExecutor[] executors) &#123;</span><br><span class="line">        <span class="keyword">this</span>.executors = executors;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executors[Math.abs(idx.getAndIncrement() % executors.length)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，上面的那个疑问算是有了一个答案。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-02-01T09:20:31.000Z" title="2/1/2020, 5:20:31 PM">2020-02-01</time>发表</span><span class="level-item"><time dateTime="2021-12-31T15:42:52.051Z" title="12/31/2021, 11:42:52 PM">2021-12-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a></span><span class="level-item">28 分钟读完 (大约4201个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/01/3831abf370d2.html">真实记录一次对项目中代码的重构过程</a></h1><div class="content">这份记录来自对项目中下单接口重构，详细记录了每一步操作、以及运用到的一些方法。力求能够最大程度将当时的过程展现出来。准备重构中的每次修改都需要进行测试，用来验证修改是否正确，因此单元测试是一个非常好的选择。单元测试单元测试中可以进行mock操作，从烦人的token中摆脱出来，做到在任何人的IDE里面</div><a class="article-more button is-small is-size-7" href="/2020/02/01/3831abf370d2.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-02-01T09:17:09.000Z" title="2/1/2020, 5:17:09 PM">2020-02-01</time>发表</span><span class="level-item"><time dateTime="2021-12-31T15:45:00.381Z" title="12/31/2021, 11:45:00 PM">2021-12-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span> / </span><a class="link-muted" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/">后端开发</a></span><span class="level-item">3 分钟读完 (大约389个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/01/ccf7f43b1e3f.html">云主机如何应对大批量的漏洞测试请求</a></h1><div class="content">云主测试工具在做测试，通过日志发现，其搜寻的漏洞内容包括：SQL注入、XSS等。由于其请求的频率过高，以致于nginx做转发出现502错误，造成了宕机的假象。正对这种情况，想到了以下两种处理方式。wordpress拒绝请</div><a class="article-more button is-small is-size-7" href="/2020/02/01/ccf7f43b1e3f.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-02-01T08:26:38.000Z" title="2/1/2020, 4:26:38 PM">2020-02-01</time>发表</span><span class="level-item"><time dateTime="2022-04-20T16:26:05.593Z" title="4/21/2022, 12:26:05 AM">2022-04-21</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span><span class="level-item">5 分钟读完 (大约818个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/02/01/652f972433d5.html">0 | Netty：简略梳理IO模型</a></h1><div class="content">这是一篇对IO模式知识点的简要笔记，后续会根据知识的积累与理解继续做更新。几种常见的IO名称最早接触的是BIO，在Java的网络编程中，有一个ServerSocket，会调用accept()方法，监听某个端口，直到有新的连接进来，代码才会继续往后执行；再到后面是NIO，一说是New IO，又说是No</div><a class="article-more button is-small is-size-7" href="/2020/02/01/652f972433d5.html#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-01-01T15:52:01.000Z" title="1/1/2020, 11:52:01 PM">2020-01-01</time>发表</span><span class="level-item"><time dateTime="2021-02-09T03:03:07.103Z" title="2/9/2021, 11:03:07 AM">2021-02-09</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span><span class="level-item">16 分钟读完 (大约2458个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/01/735c928aff1c.html">1 | netty：粘包与拆包的处理</a></h1><div class="content"><blockquote>
<p>TCP是个流协议，流是一串没有界限的数据。TCP会根据TCP缓冲区的实际情况对包进行划分。因此造成一个完整的业务包，会被TCP分成多个包、把多个包封装成一个大的包进行发送。</p>
</blockquote>
<h2 id="粘包与拆包现象"><a href="#粘包与拆包现象" class="headerlink" title="粘包与拆包现象"></a>粘包与拆包现象</h2><p><img src="/images/pics/35bb7ac36974f8bac08197cfa76f3a7a.png"></p>
<ol>
<li><p>服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包；</p>
</li>
<li><p>服务端一次接收到了两个数据包，D1和D2粘合在一起，被称为TCP粘包；</p>
</li>
<li><p>服务端分两次读取到了两个数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这被称为TCP拆包；</p>
</li>
<li><p>服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余内容D1_2和D2包的整包。</p>
</li>
</ol>
<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><ol>
<li><p>应用程序write写入的字节<strong>大小/大于</strong>套接口发送缓冲区大小；</p>
</li>
<li><p>进行MSS大小的TCP分段；</p>
</li>
<li><p>以太网帧的payload大于MTU进行IP分片。</p>
</li>
</ol>
<p><img src="/images/pics/d417146f30ff6877776c254d2e3fd9f0.png"></p>
<p>对于Linux，发送缓冲区的默认值为：<code>16384</code>。可使用下面命令查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 接收</span></span><br><span class="line">cat /proc/sys/net/ipv4/tcp_rmem</span><br><span class="line"><span class="meta">#</span><span class="bash"> min   default max</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4096	87380	6291456 (单位：byte)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4K		85K		6M</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发送(单位：byte)</span></span><br><span class="line">cat /proc/sys/net/ipv4/tcp_wmem</span><br><span class="line"><span class="meta">#</span><span class="bash"> min   default max</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4096	16384	4194304  (单位：byte)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4K		16K		4M</span></span><br></pre></td></tr></table></figure>

<p><em>数据来自百度云的云服务器</em>：</p>
<p><img src="/images/pics/8fd267756a9d7b24d521c6f2e20c0c27.png"></p>
<p>对于MacOS，可参考：<code>sysctl net.inet.tcp</code>，但是好像没找到与linux类似的参数。</p>
<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p><img src="/images/pics/646532a0a83a3089efa44ce3734c43a8.png"></p>
<h2 id="Netty如何解决"><a href="#Netty如何解决" class="headerlink" title="Netty如何解决"></a>Netty如何解决</h2><p><img src="/images/pics/ce78d7dedb455bcbc4c2c8979ca4688f.png"></p>
<p>Netty中主要是在收到数据后，对数据进行处理解码处理时，根据不同的策略，进行了拆包操作，然后将得到的完整的业务数据包传递给下个处理逻辑。分割前后的逻辑主要在<code>ByteToMessageDecoder</code>这个类中。它的继承如下：</p>
<p><img src="/images/pics/9e614ec0a7f941efbcbc719d7967a5c0.png"></p>
<p>每次从TCP缓冲区读到数据都会调用其<code>channelRead()</code>方法。这个函数的处理逻辑是：</p>
<ol>
<li>用累加器<code>cumulator</code>将新读入的数据(<code>ByteBuf</code>)存储到<code>cumulation</code>中；</li>
<li>调用解码器</li>
</ol>
<p><img src="/images/pics/b46d90ec2168530c8676d78b3167085d.png"></p>
<h3 id="累加器"><a href="#累加器" class="headerlink" title="累加器"></a>累加器</h3><p>存在两个累加器，<code>MERGE_CUMULATOR</code>和<code>COMPOSITE_CUMULATOR</code>。默认的是前者，即:<code>private Cumulator cumulator = MERGE_CUMULATOR;</code>。</p>
<p><code>MERGE_CUMULATOR</code>会先判断是否需要扩容，然后再将收到的msg拷贝到<code>cumulation</code>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Cumulate &#123;<span class="doctag">@link</span> ByteBuf&#125;s by merge them into one &#123;<span class="doctag">@link</span> ByteBuf&#125;&#x27;s, using memory copies.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Cumulator MERGE_CUMULATOR = <span class="keyword">new</span> Cumulator() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ByteBuf <span class="title">cumulate</span><span class="params">(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> required = in.readableBytes();</span><br><span class="line">            <span class="keyword">if</span> (required &gt; cumulation.maxWritableBytes() ||</span><br><span class="line">                    (required &gt; cumulation.maxFastWritableBytes() &amp;&amp; cumulation.refCnt() &gt; <span class="number">1</span>) ||</span><br><span class="line">                    cumulation.isReadOnly()) &#123;</span><br><span class="line">                <span class="comment">// Expand cumulation (by replacing it) under the following conditions:</span></span><br><span class="line">                <span class="comment">// - cumulation cannot be resized to accommodate the additional data</span></span><br><span class="line">                <span class="comment">// - cumulation can be expanded with a reallocation operation to accommodate but the buffer is</span></span><br><span class="line">                <span class="comment">//   assumed to be shared (e.g. refCnt() &gt; 1) and the reallocation may not be safe.</span></span><br><span class="line">                <span class="keyword">return</span> expandCumulation(alloc, cumulation, in);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cumulation.writeBytes(in);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// We must release in in all cases as otherwise it may produce a leak if writeBytes(...) throw</span></span><br><span class="line">            <span class="comment">// for whatever release (for example because of OutOfMemoryError)</span></span><br><span class="line">            in.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>扩容的过程是先得到一个能够容纳下原数据+当前数据的收集器，然后将原数据和当前数据依次拷贝进入收集器，最后释放旧的收集器里面的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ByteBuf <span class="title">expandCumulation</span><span class="params">(ByteBufAllocator alloc, ByteBuf oldCumulation, ByteBuf in)</span> </span>&#123;</span><br><span class="line">    ByteBuf newCumulation = alloc.buffer(alloc.calculateNewCapacity(</span><br><span class="line">            oldCumulation.readableBytes() + in.readableBytes(), MAX_VALUE));</span><br><span class="line">    ByteBuf toRelease = newCumulation;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        newCumulation.writeBytes(oldCumulation);</span><br><span class="line">        newCumulation.writeBytes(in);</span><br><span class="line">        toRelease = oldCumulation;</span><br><span class="line">        <span class="keyword">return</span> newCumulation;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        toRelease.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>COMPOSITE_CUMULATOR</code>是将每个新收到的消息，作为一个<code>Component</code>存储到收集器<code>CompositeByteBuf</code>中的<code>components</code>数组中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Cumulate &#123;<span class="doctag">@link</span> ByteBuf&#125;s by add them to a &#123;<span class="doctag">@link</span> CompositeByteBuf&#125; and so do no memory copy whenever possible.</span></span><br><span class="line"><span class="comment">    * Be aware that &#123;<span class="doctag">@link</span> CompositeByteBuf&#125; use a more complex indexing implementation so depending on your use-case</span></span><br><span class="line"><span class="comment">    * and the decoder implementation this may be slower then just use the &#123;<span class="doctag">@link</span> #MERGE_CUMULATOR&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Cumulator COMPOSITE_CUMULATOR = <span class="keyword">new</span> Cumulator() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ByteBuf <span class="title">cumulate</span><span class="params">(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cumulation.refCnt() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// Expand cumulation (by replace it) when the refCnt is greater then 1 which may happen when the</span></span><br><span class="line">                <span class="comment">// user use slice().retain() or duplicate().retain().</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// See:</span></span><br><span class="line">                <span class="comment">// - https://github.com/netty/netty/issues/2327</span></span><br><span class="line">                <span class="comment">// - https://github.com/netty/netty/issues/1764</span></span><br><span class="line">                <span class="keyword">return</span> expandCumulation(alloc, cumulation, in);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> CompositeByteBuf composite;</span><br><span class="line">            <span class="keyword">if</span> (cumulation <span class="keyword">instanceof</span> CompositeByteBuf) &#123;</span><br><span class="line">                composite = (CompositeByteBuf) cumulation;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                composite = alloc.compositeBuffer(MAX_VALUE);</span><br><span class="line">                composite.addComponent(<span class="keyword">true</span>, cumulation);</span><br><span class="line">            &#125;</span><br><span class="line">            composite.addComponent(<span class="keyword">true</span>, in);</span><br><span class="line">            in = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> composite;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// We must release if the ownership was not transferred as otherwise it may produce a leak if</span></span><br><span class="line">                <span class="comment">// writeBytes(...) throw for whatever release (for example because of OutOfMemoryError).</span></span><br><span class="line">                in.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="拆包解码流程"><a href="#拆包解码流程" class="headerlink" title="拆包解码流程"></a>拆包解码流程</h3><p><code>callDecode()</code>方法中的<code>decodeRemovalReentryProtection()</code>将调用<code>decode()</code>方法，其中<code>decode()</code>是一个抽象方法，由子类去实现。主要的子类有：</p>
<h4 id="FixedLengthFrameDecoder"><a href="#FixedLengthFrameDecoder" class="headerlink" title="FixedLengthFrameDecoder"></a><code>FixedLengthFrameDecoder</code></h4><p>里面有一个属性叫<code>frameLength</code>，用来表示消息的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A decoder that splits the received ByteBufs by the fixed number of bytes. For example, <span class="keyword">if</span> you received the following four fragmented packets:</span><br><span class="line">   +---+----+------+----+</span><br><span class="line">   | A | BC | DEFG | HI |</span><br><span class="line">   +---+----+------+----+</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">FixedLengthFrameDecoder</span><span class="params">(<span class="number">3</span>)</span> will decode them into the following three packets with the fixed length:</span></span><br><span class="line"><span class="function">   +-----+-----+-----+</span></span><br><span class="line"><span class="function">   | ABC | DEF | GHI |</span></span><br><span class="line"><span class="function">   +-----+-----+-----+</span></span><br></pre></td></tr></table></figure>
<p>流程也比较简单，收集器里面的数据长度够<code>frameLength</code>，就从收集器中截取<code>frameLength</code>byte，然后返回一个新的<code>ByteBuf</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Object decoded = decode(ctx, in);</span><br><span class="line">    <span class="keyword">if</span> (decoded != <span class="keyword">null</span>) &#123;</span><br><span class="line">        out.add(decoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a frame out of the &#123;<span class="doctag">@link</span> ByteBuf&#125; and return it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   ctx             the &#123;<span class="doctag">@link</span> ChannelHandlerContext&#125; which this &#123;<span class="doctag">@link</span> ByteToMessageDecoder&#125; belongs to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   in              the &#123;<span class="doctag">@link</span> ByteBuf&#125; from which to read data</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  frame           the &#123;<span class="doctag">@link</span> ByteBuf&#125; which represent the frame or &#123;<span class="doctag">@code</span> null&#125; if no frame could</span></span><br><span class="line"><span class="comment"> *                          be created.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@SuppressWarnings(&quot;UnusedParameters&quot;)</span> ChannelHandlerContext ctx, ByteBuf in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (in.readableBytes() &lt; frameLength) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">// 长度不够，此次decode不产生消息</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> in.readRetainedSlice(frameLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>有一个问题，如果一次收到的数据长度为<code>2 * frameLength</code>，且这个数据是最后一个数据，那么是否存在解码出现异常的情况？</strong></p>
<ol>
<li><p>有一个循环<br><img src="/images/pics/ac4079e7294317e07db56a234b691cc5.png"></p>
</li>
<li><p>输入结束的时候再次调用解码<br><img src="/images/pics/676e4c37302777d095e41c2ff02ee0e2.png"></p>
</li>
</ol>
<h4 id="LineBasedFrameDecoder"><a href="#LineBasedFrameDecoder" class="headerlink" title="LineBasedFrameDecoder"></a><code>LineBasedFrameDecoder</code></h4><p>流程是先找到当前消息中的换行符，存在且没有超过最大长度，返回解释到的数据。</p>
<h4 id="DelimiterBasedFrameDecoder"><a href="#DelimiterBasedFrameDecoder" class="headerlink" title="DelimiterBasedFrameDecoder"></a><code>DelimiterBasedFrameDecoder</code></h4><p>根据特定的字符进行分割，其中如果分割符是行标志，会调用<code>LineBasedFrameDecoder</code>进行分割解码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decode()方法中</span></span><br><span class="line"><span class="keyword">if</span> (lineBasedDecoder != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> lineBasedDecoder.decode(ctx, buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lineBasedDecoder不为空的情况是分割字符是行分割字符</span></span><br><span class="line"><span class="comment">// 构造方法中</span></span><br><span class="line"><span class="keyword">if</span> (isLineBased(delimiters) &amp;&amp; !isSubclass()) &#123;</span><br><span class="line">	lineBasedDecoder = <span class="keyword">new</span> LineBasedFrameDecoder(maxFrameLength, stripDelimiter, failFast);</span><br><span class="line">	<span class="keyword">this</span>.delimiters = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断分割符是否为行分割符的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLineBased</span><span class="params">(<span class="keyword">final</span> ByteBuf[] delimiters)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (delimiters.length != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ByteBuf a = delimiters[<span class="number">0</span>];</span><br><span class="line">	ByteBuf b = delimiters[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span> (a.capacity() &lt; b.capacity()) &#123;</span><br><span class="line">		a = delimiters[<span class="number">1</span>];</span><br><span class="line">		b = delimiters[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> a.capacity() == <span class="number">2</span> &amp;&amp; b.capacity() == <span class="number">1</span></span><br><span class="line">		&amp;&amp; a.getByte(<span class="number">0</span>) == <span class="string">&#x27;\r&#x27;</span> &amp;&amp; a.getByte(<span class="number">1</span>) == <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">		&amp;&amp; b.getByte(<span class="number">0</span>) == <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为分割字符可能是多个，当数据中存在多个分割字符的情况下，会用分割后得到的数据最短的那个分割字符。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Try all delimiters and choose the delimiter which yields the shortest frame.</span></span><br><span class="line"><span class="keyword">int</span> minFrameLength = Integer.MAX_VALUE;</span><br><span class="line">ByteBuf minDelim = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (ByteBuf delim: delimiters) &#123;</span><br><span class="line">	<span class="keyword">int</span> frameLength = indexOf(buffer, delim);</span><br><span class="line">	<span class="keyword">if</span> (frameLength &gt;= <span class="number">0</span> &amp;&amp; frameLength &lt; minFrameLength) &#123;</span><br><span class="line">		minFrameLength = frameLength;</span><br><span class="line">		minDelim = delim;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For example, if you have the following data in the buffer:<br>   +————–+<br>   | ABC\nDEF\r\n |<br>   +————–+</p>
<p>a DelimiterBasedFrameDecoder(Delimiters.lineDelimiter()) will choose ‘\n’ as the first delimiter and produce two frames:<br>   +—–+—–+<br>   | ABC | DEF |<br>   +—–+—–+</p>
<p>rather than incorrectly choosing ‘\r\n’ as the first delimiter:<br>   +———-+<br>   | ABC\nDEF |<br>   +———-+</p>
<h4 id="LengthFieldBasedFrameDecoder"><a href="#LengthFieldBasedFrameDecoder" class="headerlink" title="LengthFieldBasedFrameDecoder"></a><code>LengthFieldBasedFrameDecoder</code></h4><p>简而言之，就是在数据的头部，放一个专门的长度位，根据长度位来读取后面信息的内容。</p>
<p>这个类比较有意思，注释差不多占了2/5。主要的处理逻辑是<code>decode()</code>，但是这个方法100行都不到。注释主要解释了这个类里面几个参数的不同配置，产生不同的处理情况。</p>
<p><img src="/images/pics/5b4babfd11bc2264ee850eaa9b4cf699.png"></p>
<p>情况对应于下表：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">lengthFieldOffset</th>
<th align="center">lengthFieldLength</th>
<th align="center">lengthAdjustment</th>
<th align="center">initialBytesToStrip</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x01</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0x02</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">0x03</td>
<td align="center">0</td>
<td align="center">2</td>
<td align="center">-2</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0x04</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0x05</td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0x06</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">0x07</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">-3</td>
<td align="center">3</td>
</tr>
</tbody></table>
<h5 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h5><p><code>lengthFieldLength   = 2</code>表示长度位占头部的2 bytes，剩下的都是消息占位，也就是<code>0x000C(12) + 2 = 14</code>。</p>
<p><img src="/images/pics/d42c8f17bc19a05c0f12d1d15d962296.png"></p>
<h5 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h5><p>与<code>0x01</code>类似，只是多了<code>initialBytesToStrip = 2</code>，解码后的内容截取掉了头部的<code>initialBytesToStrip</code>位。也就是解码后的长度为<code>14 - initialBytesToStrip = 12</code>。</p>
<p><img src="/images/pics/74741522fb2030fc7e61fd26afb9a4da.png"></p>
<h5 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h5><p>这种情况下，长度位的值，表示整个包的长度，包括长度位本身的长度。<code>lengthAdjustment = -2</code>表示要将长度位的值加上<code>lengthAdjustment</code>,作为消息的长度。</p>
<p><img src="/images/pics/4356b4bae53fc742ba1af249713e5ac5.png"></p>
<h5 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h5><p>与<code>0x01</code>相比，多了个一个长度位的偏移量<code>lengthFieldOffset</code>。所以长度位的前面又可以放一些其他数据。也就是说，真正的消息是从<code>lengthFieldOffset + lengthFieldLength</code>后开始。</p>
<p><img src="/images/pics/ca61620cc07063c1f090fe124053edb3.png"></p>
<h5 id="0x05"><a href="#0x05" class="headerlink" title="0x05"></a>0x05</h5><p>与<code>0x03</code>对比，只是<code>lengthAdjustment</code>的正负不同，也就意味着真实的消息是在长度位后面是有偏移的，而偏移出来的空间，可以用作存放另外一种数据类型。</p>
<p><img src="/images/pics/2990e515d24e90cd43614561f4116d35.png"></p>
<h5 id="0x06"><a href="#0x06" class="headerlink" title="0x06"></a>0x06</h5><p>在<code>0x04</code>、<code>0x05</code>的基础上，长度位多了偏移<code>lengthFieldOffset</code>，真实的消息的偏移又多加了一个<code>lengthAdjustment</code>，然后截掉了头部开始的<code>initialBytesToStrip</code>bytes。</p>
<p><img src="/images/pics/a0725d8b3c367b3cfd27c21da88a9289.png"></p>
<h5 id="0x07"><a href="#0x07" class="headerlink" title="0x07"></a>0x07</h5><p>在<code>0x06</code>的基础上，<code>lengthAdjustment</code>变成负数了，与<code>0x03</code>的情况类似。</p>
<p><img src="/images/pics/ce5bcdd00bd25f261d16c3a1d42643db.png"></p>
<p><strong>整体代码的流程</strong><br>除去异常处理的情况，就是计算整个消息的长度，然后跳过要求跳过的字节数，再从<code>ByteBuf</code>中读取消息。如下：</p>
<p><img src="/images/pics/62b6c01865b51478140111f84d61117b.png"></p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://book.douban.com/subject/26373138/">《Netty权威指南》</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/526p5f9fgtZu7yYq5j7LiQ">netty源码分析之拆包器的奥秘</a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/10/">上一页</a></div><div class="pagination-next"><a href="/page/12/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/10/">10</a></li><li><a class="pagination-link is-current" href="/page/11/">11</a></li><li><a class="pagination-link" href="/page/12/">12</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/26/">26</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">十二月 2024</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">二月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/01/"><span class="level-start"><span class="level-item">一月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/06/"><span class="level-start"><span class="level-item">六月 2023</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">二月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/01/"><span class="level-start"><span class="level-item">一月 2023</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">十月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/08/"><span class="level-start"><span class="level-item">八月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">七月 2022</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">六月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">三月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">十月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/10/"><span class="level-start"><span class="level-item">十月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/02/"><span class="level-start"><span class="level-item">二月 2020</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/10/"><span class="level-start"><span class="level-item">十月 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/07/"><span class="level-start"><span class="level-item">七月 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/06/"><span class="level-start"><span class="level-item">六月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/05/"><span class="level-start"><span class="level-item">五月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/03/"><span class="level-start"><span class="level-item">三月 2019</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/02/"><span class="level-start"><span class="level-item">二月 2019</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/12/"><span class="level-start"><span class="level-item">十二月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/11/"><span class="level-start"><span class="level-item">十一月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">九月 2018</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">八月 2018</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/06/"><span class="level-start"><span class="level-item">六月 2018</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/05/"><span class="level-start"><span class="level-item">五月 2018</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/04/"><span class="level-start"><span class="level-item">四月 2018</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">三月 2018</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/02/"><span class="level-start"><span class="level-item">二月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/01/"><span class="level-start"><span class="level-item">一月 2018</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/12/"><span class="level-start"><span class="level-item">十二月 2017</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/10/"><span class="level-start"><span class="level-item">十月 2017</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/09/"><span class="level-start"><span class="level-item">九月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/03/"><span class="level-start"><span class="level-item">三月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/01/"><span class="level-start"><span class="level-item">一月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2016/12/"><span class="level-start"><span class="level-item">十二月 2016</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2024/12/09/249b2dc63505.html"><img src="/images/pics/5300c911560a8d2e0d745dcaf025d22f.jpg" alt="M系列MacBook连接l2tp时失败的问题修复"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-12-08T16:00:00.000Z">2024-12-09</time></p><p class="title"><a href="/2024/12/09/249b2dc63505.html">M系列MacBook连接l2tp时失败的问题修复</a></p><p class="categories"><a href="/categories/macOS/">macOS</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2024/12/09/e9036e8500f6.html"><img src="/images/thumbnails/rust-lang.png" alt="Rust学习笔记"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-12-08T16:00:00.000Z">2024-12-09</time></p><p class="title"><a href="/2024/12/09/e9036e8500f6.html">Rust学习笔记</a></p><p class="categories"><a href="/categories/Rust/">Rust</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2024/12/09/4948e86c1262.html"><img src="/images/pics/DrRvr9.jpg" alt="Calico证书学习笔记"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-12-08T16:00:00.000Z">2024-12-09</time></p><p class="title"><a href="/2024/12/09/4948e86c1262.html">Calico证书学习笔记</a></p><p class="categories"><a href="/categories/Kubernetes/">Kubernetes</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2024/12/09/6dae87e31dc3.html"><img src="/images/pics/e9f22d889a230bfda8e24c0a981740a8.png" alt="如何在YAML文件中进行优雅地换行"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-12-08T16:00:00.000Z">2024-12-09</time></p><p class="title"><a href="/2024/12/09/6dae87e31dc3.html">如何在YAML文件中进行优雅地换行</a></p><p class="categories"><a href="/categories/Golang/">Golang</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2024/12/09/25470f32f4bb.html"><img src="/images/pics/kubernetes-cka-color.svg" alt="CKS证书学习资料汇编"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-12-08T16:00:00.000Z">2024-12-09</time></p><p class="title"><a href="/2024/12/09/25470f32f4bb.html">CKS证书学习资料汇编</a></p><p class="categories"><a href="/categories/Kubernetes/">Kubernetes</a></p></div></article></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://crisfang.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Cris</span></span><span class="level-right"><span class="level-item tag">crisfang.com</span></span></a></li><li><a class="level is-mobile" href="https://sanyuesha.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">三月沙</span></span><span class="level-right"><span class="level-item tag">sanyuesha.com</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/images/pics/d261cdb6203e0da42ae1324dd3aae11f.png" alt="遇寻笔记" height="28"></a><p class="is-size-7"><span>&copy; 2024 遇寻</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="To Find Me" href="https://github.com/eucham"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="LinkedIn" href="https://www.linkedin.com/in/eucham"><i class="fab fa-linkedin"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>